<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Songkc&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/6c8095f369fe745094e7e72f87054027</icon>
  <subtitle>Talk is cheap, show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://songkc.github.io/"/>
  <updated>2019-03-28T18:38:14.014Z</updated>
  <id>https://songkc.github.io/</id>
  
  <author>
    <name>Songkc</name>
    <email>weijia_sysu@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer - 删除链表中重复的结点</title>
    <link href="https://songkc.github.io/2019/03/24/%E5%89%91%E6%8C%87Offer-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>https://songkc.github.io/2019/03/24/剑指Offer-删除链表中重复的结点/</id>
    <published>2019-03-23T18:03:24.000Z</published>
    <updated>2019-03-28T18:38:14.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h3><p>使用三个指针，分别是指向当前结点的前一结点的指针 <strong>prev</strong>，指向当前结点的指针 <strong>curr</strong>，指向当前结点的后一结点的指针 <strong>latter</strong>，为了让第一个节点也有前一结点，定义一个 <strong>ListNode head</strong> 变量，其 <strong>next</strong> 值指向第一个结点。</p><p>接着从 <strong>curr</strong> 为第一个结点开始遍历，直到 <strong>latter</strong> 为 <strong>nullptr</strong>。</p><ul><li>遍历过程中如果 <strong>curr</strong> 与 <strong>latter</strong> 的值不同，则 <strong>prev, curr, latter</strong> 都往后移一个结点；</li><li>如果遇到 <strong>curr</strong> 和 <strong>latter</strong> 的值相同，就需要再进入一层循环，删除每一个与 <strong>curr</strong> 值相同的 <strong>latter</strong>，并将 <strong>latter</strong> 指向其自身的下一个，直到 <strong>latter</strong> 与 <strong>curr</strong> 的值不同或 <strong>latter</strong> 为 <strong>nullptr</strong> 则第二层循环结束，并将当前的 <strong>curr</strong> 结点也删除，然后 <strong>curr</strong> 指向当前 <strong>latter</strong> 的结点，<strong>prev-&gt;next</strong> 指向 <strong>curr</strong>，如果 <strong>latter</strong> 不为 <strong>nullptr</strong> 则 <strong>latter</strong> 指向当前 <strong>latter</strong> 的下一个结点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode head(0), *temp = nullptr;</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        ListNode *prev = &amp;head, *curr = pHead, *latter = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (latter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == latter-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">while</span> (latter != <span class="literal">nullptr</span> &amp;&amp; curr-&gt;val == latter-&gt;val) &#123;</span><br><span class="line">                    temp = latter;</span><br><span class="line">                    latter = latter-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = curr;</span><br><span class="line">                curr = latter;</span><br><span class="line">                prev-&gt;next = curr;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">if</span> (latter != <span class="literal">nullptr</span>) latter = latter-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = latter;</span><br><span class="line">                latter = latter-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>递归的主要思路是：判断当前结点与下一结点的值是否相同，如果不同则当前结点为不重复的一个结点，然后就是从当前结点指向的下一个结点开始找不重复的结点；如果当前结点与下一结点的值相同，那么就需要找到第一个与当前结点不同的结点，然后从这个结点开始再找不重复的结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode *node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;val != pHead-&gt;next-&gt;val) &#123;</span><br><span class="line">            node = pHead;</span><br><span class="line">            node-&gt;next = deleteDuplication(node-&gt;next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line">            node = pHead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;val == node-&gt;val) &#123;</span><br><span class="line">                temp = node;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> pHead;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 从第一个与当前结点不同的结点再次开始递归</span></span><br><span class="line">            node = deleteDuplication(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&amp;gt;2
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 142. Linked List Cycle II</title>
    <link href="https://songkc.github.io/2019/03/23/LeetCode-142-Linked-List-Cycle-II/"/>
    <id>https://songkc.github.io/2019/03/23/LeetCode-142-Linked-List-Cycle-II/</id>
    <published>2019-03-23T13:28:14.000Z</published>
    <updated>2019-03-29T18:28:18.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">Output: tail connects to node index <span class="number">1</span></span><br><span class="line">Explanation: There is a cycle in the linked <span class="built_in">list</span>, where tail connects to the</span><br><span class="line">second node.</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/circularlinkedlist_test1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output: tail connects to node index <span class="number">0</span></span><br><span class="line">Explanation: There is a cycle in the linked <span class="built_in">list</span>, where tail connects to the</span><br><span class="line">first node.</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/circularlinkedlist_test2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked <span class="built_in">list</span>.</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/circularlinkedlist_test3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="使用-stl-map"><a href="#使用-stl-map" class="headerlink" title="使用 stl::map"></a>使用 stl::map</h3><p><strong>map&lt;ListNode*, int&gt;</strong> 将 <strong>ListNode*</strong> 与 <strong>ListNode*</strong> 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 <strong>next</strong> 指向的 <strong>nullptr</strong> 时就会结束遍历，返回 <strong>nullptr</strong>；而如果单链表中存在环，第一个出现次数大于 <strong>1</strong> 的结点即环的入口结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; lmap;</span><br><span class="line">      ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lmap.count(node) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> (lmap[node] = <span class="number">1</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-stl-set"><a href="#使用-stl-set" class="headerlink" title="使用 stl::set"></a>使用 stl::set</h3><p>与使用 stl::map 的思路相似，故不再叙述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; nodeset;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeset.count(head) &gt; <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">            nodeset.insert(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><h3 id="使用快慢指针"><a href="#使用快慢指针" class="headerlink" title="使用快慢指针"></a>使用快慢指针</h3><p>设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。</p><p>此时，会出现两种情况：</p><ul><li><p>单链表中不存在环则：快指针往后遍历的过程中，会遍历到 <strong>nullptr</strong> 结点，即单链表中不存在环，最后一个结点指向的是 <strong>nullptr</strong>。</p></li><li><p>单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。</p><p><img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/cycle.png" alt=""></p><ul><li><p>如果这时快指针已经是在环里走了 <strong>1</strong> 圈（对应于非环部分较短的情况）：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)</strong> 距离，<strong>2(x + d) = x + y + d</strong> ，可得 <strong>x = y - d</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。</p></li><li><p>如果这时快指针已经是在环里走了不止一圈，假设为 <strong>k</strong> 圈：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)​</strong> 距离，<strong>2(x + d) = x +ky + d​</strong>，可得 <strong>x = ky - d​</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      ListNode *slow = head, *fast = head;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">      fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细思路参考：<a href="https://www.cnblogs.com/zhuzhenwei918/p/7491892.html" target="_blank" rel="noopener">一个链表中包含环，请找出该链表的环的入口结点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given a linked list, return the no
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer - 链表中环的入口结点</title>
    <link href="https://songkc.github.io/2019/03/23/%E5%89%91%E6%8C%87Offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>https://songkc.github.io/2019/03/23/剑指Offer-链表中环的入口结点/</id>
    <published>2019-03-23T10:11:33.000Z</published>
    <updated>2019-03-26T19:20:26.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 <strong>NULL</strong>。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="使用-stl-map"><a href="#使用-stl-map" class="headerlink" title="使用 stl::map"></a>使用 stl::map</h3><p><strong>map&lt;ListNode*, int&gt;</strong> 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 <strong>next</strong> 指向的 <strong>nullptr</strong> 时就会结束遍历，返回 <strong>nullptr</strong>；而如果单链表中存在环，第一个出现次数大于 <strong>1</strong> 的结点即环的入口结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// method via stl::map</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; lmap;</span><br><span class="line">      ListNode *node = pHead;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lmap.count(node) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> (lmap[node] = <span class="number">1</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-stl-set"><a href="#使用-stl-set" class="headerlink" title="使用 stl::set"></a>使用 stl::set</h3><p>与使用 stl::map 的思路相似，故不再叙述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// method via stl::set</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; nodeset;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeset.count(pHead) &gt; <span class="number">0</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">            nodeset.insert(pHead);</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用快慢指针"><a href="#使用快慢指针" class="headerlink" title="使用快慢指针"></a>使用快慢指针</h3><p>设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。</p><p>此时，会出现两种情况：</p><ul><li><p>单链表中不存在环则：快指针往后遍历的过程中，会遍历到 <strong>nullptr</strong> 结点，即单链表中不存在环，最后一个结点指向的是 <strong>nullptr</strong>。</p></li><li><p>单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。</p><p><img src="/2019/03/23/剑指Offer-链表中环的入口结点/cycle.png" alt=""></p><ul><li><p>如果这时快指针已经是在环里走了 <strong>1</strong> 圈（对应于非环部分较短的情况）：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)</strong> 距离，<strong>2(x + d) = x + y + d</strong> ，可得 <strong>x = y - d</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。</p></li><li><p>如果这时快指针已经是在环里走了不止一圈，假设为 <strong>k</strong> 圈：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)​</strong> 距离，<strong>2(x + d) = x +ky + d​</strong>，可得 <strong>x = ky - d​</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// method via fast pointer and slow pointer</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      ListNode *slow = pHead, *fast = pHead;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">      fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细思路参考：<a href="https://www.cnblogs.com/zhuzhenwei918/p/7491892.html" target="_blank" rel="noopener">一个链表中包含环，请找出该链表的环的入口结点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 &lt;strong&gt;NULL&lt;/strong&gt;。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer - 二叉树的镜像</title>
    <link href="https://songkc.github.io/2019/03/22/%E5%89%91%E6%8C%87Offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>https://songkc.github.io/2019/03/22/剑指Offer-二叉树的镜像/</id>
    <published>2019-03-22T03:19:58.000Z</published>
    <updated>2019-03-26T19:07:39.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：</span><br><span class="line">             源二叉树                    镜像二叉树</span><br><span class="line">                8                          8 </span><br><span class="line">               /  \                       /  \</span><br><span class="line">              6   10                     10   6</span><br><span class="line">             / \  / \                   / \  / \</span><br><span class="line">            5  7  9 11                 11  9 7  5</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>对于每个二叉树结点都将左右子结点交换就可以，因此递归是最简短的形式，可以先继续递归左右子结点再交换左右子结点，也可以先交换左右子结点再继续递归左右子结点。</p><p>继续递归左右子结点时，可以先检查左右子结点是否为 <strong>nullptr</strong>，如果子结点是 <strong>nullptr</strong>，则不需要进行递归，可以减少内存空间和运行时间的消耗，因为递归需要为递归函数的参数和局部变量分配内存空间，同时还需要对递归函数进行压栈操作和递归函数执行及执行完后的出栈操作，这些都需要消耗时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot-&gt;left  != <span class="literal">nullptr</span>) Mirror(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pRoot-&gt;right != <span class="literal">nullptr</span>) Mirror(pRoot-&gt;right);</span><br><span class="line">        TreeNode* temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="stl-queue-非递归方法"><a href="#stl-queue-非递归方法" class="headerlink" title="stl::queue 非递归方法"></a>stl::queue 非递归方法</h3><p>通过队列以层次遍历的方式，遍历每一个二叉树结点，取出结点将左右子结点交换，再将非 <strong>nullptr</strong> 的子结点加入队列中，直到队列为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        TreeNode *node = <span class="literal">nullptr</span>, *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (que.empty() == <span class="literal">false</span>) &#123;</span><br><span class="line">            node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            temp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = temp;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left  != <span class="literal">nullptr</span>) que.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) que.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="stl-stack-非递归方法"><a href="#stl-stack-非递归方法" class="headerlink" title="stl::stack 非递归方法"></a>stl::stack 非递归方法</h3><p>与 stl::queue 的思路相似，故不再叙述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(pRoot);</span><br><span class="line">        TreeNode *node = <span class="literal">nullptr</span>, *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (stk.empty() == <span class="literal">false</span>) &#123;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            temp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = temp;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left  != <span class="literal">nullptr</span>) stk.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) stk.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/p&gt;
&lt;h2 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二叉树" scheme="https://songkc.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 671. Second Minimum Node in a Binary Tree</title>
    <link href="https://songkc.github.io/2018/10/15/LeetCode-671-Second-Minimum-Node-In-a-Binary-Tree/"/>
    <id>https://songkc.github.io/2018/10/15/LeetCode-671-Second-Minimum-Node-In-a-Binary-Tree/</id>
    <published>2018-10-15T02:01:22.000Z</published>
    <updated>2019-03-29T18:40:20.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes.</p><p>Given such a binary tree, you need to output the <strong>second minimum</strong> value in the set made of all the nodes’ value in the whole tree.</p><p>If no such second minimum value exists, output -1 instead.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 1</span></span><br><span class="line">Input:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">5</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: The smallest value is <span class="number">2</span>, the second smallest value is <span class="number">5.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 2</span></span><br><span class="line">Input:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Output: <span class="number">-1</span></span><br><span class="line">Explanation: The smallest value is <span class="number">2</span>, but there isn't any second smallest value.</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由题意可知，父节点的值一定小于等于两个子节点的值，因而根节点的值一定是最小值，那么可以推导出值第二小的节点在根节点的左子树中或在根节点的右子树中或不存在，同时，当一个节点的值大于根节点的值(即最小值)时，由于父节点的值一定小于等于两个子节点的值，那么由该节点衍生的子树的节点的值一定大于等于该节点的值，因此该节点衍生的子树并不需要检查。</p><p>解决的方法有多种，这里我使用了 BFS（广度优先搜索）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// unrecursion by BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">int</span> min = root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> left, right, smin = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* temp = que.front();</span><br><span class="line">            <span class="keyword">if</span> (min &lt; temp-&gt;val) &#123;</span><br><span class="line">                smin = (smin &gt; temp-&gt;val ? temp-&gt;val : smin);</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span> &amp;&amp; temp-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                que.push(temp-&gt;left);</span><br><span class="line">                que.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> smin == INT_MAX ? <span class="number">-1</span> : smin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>学习了一下 LeetCode 上讨论区的做法，将递归和分治的做法也写出来。</p><h3 id="Recursion-Method（递归方法）"><a href="#Recursion-Method（递归方法）" class="headerlink" title="Recursion Method（递归方法）"></a>Recursion Method（递归方法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> findSecMin(root, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecMin</span><span class="params">(TreeNode* node, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &gt; first) <span class="keyword">return</span> node-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = findSecMin(node-&gt;left, first);</span><br><span class="line">        <span class="keyword">int</span> right = findSecMin(node-&gt;right, first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="number">-1</span> &amp;&amp; left == <span class="number">-1</span>) <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Divide-and-Conquer-Method-（分治方法）"><a href="#Divide-and-Conquer-Method-（分治方法）" class="headerlink" title="Divide and Conquer Method （分治方法）"></a>Divide and Conquer Method （分治方法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// divide and conquer</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> right = root-&gt;right-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == root-&gt;val)</span><br><span class="line">            left = findSecondMinimumValue(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (right == root-&gt;val)</span><br><span class="line">            right = findSecondMinimumValue(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left &gt; right ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given a non-empty special binary t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="二叉树" scheme="https://songkc.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 32. Longest Valid Parentheses</title>
    <link href="https://songkc.github.io/2018/10/11/LeetCode-32-Longest-Valid-Parentheses/"/>
    <id>https://songkc.github.io/2018/10/11/LeetCode-32-Longest-Valid-Parentheses/</id>
    <published>2018-10-11T06:41:29.000Z</published>
    <updated>2019-03-29T18:36:28.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For <span class="string">"(()"</span>, the longest valid parentheses substring is <span class="string">"()"</span>, which has</span><br><span class="line">length = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">Another example is <span class="string">")()())"</span>, where the longest valid parentheses</span><br><span class="line">substring is <span class="string">"()()"</span>, which has length = <span class="number">4.</span></span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一开始只是简单的以为是求出所有合法的圆括号的数量，就直接用一个<strong>栈</strong>去写，提交后才发现理解错了，原来题目的意思是从找出字符串中最长的合法圆括号子串的长度。</p><p>重新审题后就能发现每个合法的字串其实都是由不合法的字串分隔开的，我的思路是用一个栈存储 <code>pair&lt;char, int&gt;</code> 类型的元素，<strong>char</strong> 为圆括号字符，<strong>int</strong> 为此时所有合法的圆括号数量。当栈顶元素字符为 <strong>‘(‘</strong> 且当前字符为 <strong>‘)’</strong> 时，就将栈顶元素 <strong>pop</strong> 出，并将合法圆括号数量 <strong>+2</strong>，到最后栈中留下的都是不合法的圆括号，其实就相当于将合法的圆括号字串分隔开的分隔符，此时就可以利用这些分隔符求出每个合法圆括号字串的长度，取最大的字串长度即可。算法的复杂度是 $O(n^2)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &gt; stk;</span><br><span class="line">        pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; p(s[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        stk.push(p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; temp(s[i], count);</span><br><span class="line">                stk.push(temp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; top = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (top.first == <span class="string">'('</span> &amp;&amp; s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                count += <span class="number">2</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; temp(s[i], count);</span><br><span class="line">                stk.push(temp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; top = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (top.second == count) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = count - top.second;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; temp) max = temp;</span><br><span class="line">            count -= temp;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; count) max = count;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><h3 id="精简代码"><a href="#精简代码" class="headerlink" title="精简代码"></a>精简代码</h3><p>LeetCode 讨论区发现，许多解答思路与我的思路是一样的，但我的代码显得有些冗余了，附上精简后的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            temp = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="number">-1</span> &amp;&amp; s[i] == <span class="string">')'</span> &amp;&amp; s[temp] == <span class="string">'('</span>) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                maxL = max(maxL, i - stk.top());</span><br><span class="line">            &#125; <span class="keyword">else</span> stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>还有用使用动态规划（DP）算法来解题的思路，这里也在此附上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *V = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) ++open;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">')'</span> &amp;&amp; open &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// matches found</span></span><br><span class="line">                V[i] = V[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// add matches from previous</span></span><br><span class="line">                <span class="keyword">if</span> (i - V[i] &gt; <span class="number">0</span>) V[i] += V[i - V[i]];</span><br><span class="line"></span><br><span class="line">                --open;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (V[i] &gt; max) max = V[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> V;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Given a string containing ju
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://songkc.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="https://songkc.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 551. Student Attendance Record I</title>
    <link href="https://songkc.github.io/2018/10/05/LeetCode-551-Student-Attendence-Record-I/"/>
    <id>https://songkc.github.io/2018/10/05/LeetCode-551-Student-Attendence-Record-I/</id>
    <published>2018-10-05T01:02:33.000Z</published>
    <updated>2019-03-28T18:49:27.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:</p><ol><li><strong>‘A’</strong> : Absent.</li><li><strong>‘L’</strong> : Late.</li><li><strong>‘P’</strong> : Present.</li></ol><p>A student could be rewarded if his attendance record doesn’t contain <strong>more than one ‘A’ (absent)</strong> or <strong>more than two continuous ‘L’ (late)</strong>.</p><p>You need to return whether the student could be rewarded according to his attendance record.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"PPALLP"</span></span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"PPALLL"</span></span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先分析题目，根据题目的意思是说，只要缺勤超过两次或者迟到超过两次且是连续的就应该返回 <strong>false</strong>，缺勤超过两次这个直接记录就 OK，而这题的重点用更通俗的话来讲就是连续两天以上迟到，其实最简单的做法就是用一个变量 <code>late</code> 记录迟到的次数，迟到则加 <strong>1</strong>，不是迟到的则将 <strong>late</strong> 重置为 <strong>0</strong>，然后判断 <strong>late</strong> 是否大于 <strong>2</strong> 即可。这题算是比较简单的，巧妙的 <strong>if-else</strong> 就可以做出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">abs</span> = <span class="number">0</span>, late = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'A'</span>) <span class="built_in">abs</span>++;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'L'</span>) late++;</span><br><span class="line">            <span class="keyword">else</span> late = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span> &gt; <span class="number">1</span> || late &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;You are given a string representin
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://songkc.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 48. Rotate Image</title>
    <link href="https://songkc.github.io/2018/09/30/LeetCode-48-Rotate-Image/"/>
    <id>https://songkc.github.io/2018/09/30/LeetCode-48-Rotate-Image/</id>
    <published>2018-09-30T11:54:52.000Z</published>
    <updated>2019-03-29T18:29:24.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</li><li>Rotate the image by 90 degrees (clockwise).</li></ul><p><strong>Note:</strong> You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>问题主要在于不能使用额外的2维矩阵去求解，思路其实就是由内圈到外圈将整个矩阵顺时针旋转 90°，一是存放当前位置的值以便旋转后将值赋值到旋转后的新位置，二是推导出从当前位置到旋转后的新位置的公式，上述一二操作循环四个数字即可。整个算法的时间复杂度是 $O(n^2)​$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; matrix.size() - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                row = i; col = j;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; ++k) &#123;</span><br><span class="line">                    tmp = matrix[row][col];</span><br><span class="line">                    matrix[row][col] = temp;</span><br><span class="line">                    temp = row;</span><br><span class="line">                    row = col;</span><br><span class="line">                    col = matrix.size() - <span class="number">1</span> - temp;</span><br><span class="line">                    temp = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  n represents the matrix's dimension</span></span><br><span class="line"><span class="comment">  row represents the row of the present position</span></span><br><span class="line"><span class="comment">  col represents the column of the present position</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Actually, the transform function can be written as:</span></span><br><span class="line"><span class="comment">  new_row = col</span></span><br><span class="line"><span class="comment">  new_col = n - row - 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Example:</span></span><br><span class="line"><span class="comment">  1 2 3        7 2 1        7 4 1</span></span><br><span class="line"><span class="comment">  4 5 6   -&gt;   4 5 6   -&gt;   8 5 2</span></span><br><span class="line"><span class="comment">  7 8 9       9 8 3        9 6 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>LeetCode 讨论区上见到的，先将矩阵按主对角线翻转，再将翻转后的矩阵的每一行进行逆序，就可以完成对矩阵的 90° 旋转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = m.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                swap(m[i][j], m[j][i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            reverse(m[i].begin(), m[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Example:</span></span><br><span class="line"><span class="comment">  1 2 3        1 4 7        7 4 1</span></span><br><span class="line"><span class="comment">  4 5 6   -&gt;   2 5 8   -&gt;   8 5 2</span></span><br><span class="line"><span class="comment">  7 8 9       3 6 9        9 6 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;You are given an &lt;em&gt;n&lt;/em&gt; 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://songkc.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 21. Merge Two Sorted Lists</title>
    <link href="https://songkc.github.io/2018/09/25/LeetCode-21-Merge-Two-Sorted-Lists/"/>
    <id>https://songkc.github.io/2018/09/25/LeetCode-21-Merge-Two-Sorted-Lists/</id>
    <published>2018-09-25T05:14:51.000Z</published>
    <updated>2019-03-29T18:29:01.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>合并两个已按小到大排序的链表，最简单的做法就是新建一个链表，然后比较原有的两个链表当前节点的大小，然后选择较小的节点加到新建链表上，接着将被选中的链表的节点指向他的下一个，重复以上，知道某个链表已读到末尾或两个链表都为空，然后将未读完的链表的节点直接加到新建链表上就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                node-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = (l1 == <span class="literal">NULL</span> ? l2 : l1);</span><br><span class="line">        node = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>还可以通过递归实现，原理与上面相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* node;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            node = l1;</span><br><span class="line">            node-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = l1;</span><br><span class="line">            node-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Merge two sorted linked list
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 2. Add Two Numbers</title>
    <link href="https://songkc.github.io/2018/09/19/LeetCode-2-Add-Two-Numbers/"/>
    <id>https://songkc.github.io/2018/09/19/LeetCode-2-Add-Two-Numbers/</id>
    <published>2018-09-19T02:58:21.000Z</published>
    <updated>2019-03-29T18:28:35.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</li><li>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">  </span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目挺简单的，就是通过链表实现大数加法，结果的每一位由三个值决定，两个是两个加数在这个数位上的值，剩下一个是上一位的进位，主要就是需要注意进位的实现，也没什么难度，可能还有需要注意的就是代码的逻辑需要简明清晰，不然很容易写的很冗长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, tmp = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *p1 = l1, *p2 = l2, *temp = <span class="literal">NULL</span>, *result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span> || p2 != <span class="literal">NULL</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            n1 = (p1 != <span class="literal">NULL</span>) ? p1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            n2 = (p2 != <span class="literal">NULL</span>) ? p2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span> temp-&gt;next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            p1 = (p1 == <span class="literal">NULL</span>) ? p1 : p1-&gt;next;</span><br><span class="line">            p2 = (p2 == <span class="literal">NULL</span>) ? p2 : p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = result;</span><br><span class="line">            <span class="keyword">else</span> temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>在 LeetCode 讨论区中发现了更简洁的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    ListNode preHead(0), *p = &amp;preHead;</span><br><span class="line">    <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + extra;</span><br><span class="line">        extra = sum / <span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;You are given two &lt;strong&gt;no
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 1. Two Sum</title>
    <link href="https://songkc.github.io/2018/09/12/LeetCode-1-Two-Sum/"/>
    <id>https://songkc.github.io/2018/09/12/LeetCode-1-Two-Sum/</id>
    <published>2018-09-12T14:20:34.000Z</published>
    <updated>2019-03-27T17:58:10.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一开始，我想到用 <strong>stl::map</strong> 来解决，数组元素值作为 <strong>map</strong> 的键，下标则是作为对应的值。将 <strong>target</strong> 减去当前元素值，看 <strong>map</strong> 中是否存在差值的键值，如果存在就说明找到了，不存在则将当前元素值和对应下标存入 <strong>map</strong> 中，以便后面的元素能对应。</p><p>但是，我发现如果出现目标是一个元素的两倍，那么输出的结果将是两次那个元素的下标。为了解决这个情况，我调整了一下语句的顺序，将对 <strong>map</strong> 赋值的语句放到查找后，这样就不会出现上面所说的问题了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.g</span></span><br><span class="line">intput: [<span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">7</span> <span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">output: [<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; reflect;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reflect.find(target - nums[i]) != reflect.end()) &#123;</span><br><span class="line">                result.push_back(reflect[target - nums[i]]);</span><br><span class="line">                result.push_back(reflect[nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            reflect[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given an array of integers, return
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://songkc.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="https://songkc.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://songkc.github.io/2018/09/01/hello-world/"/>
    <id>https://songkc.github.io/2018/09/01/hello-world/</id>
    <published>2018-09-01T04:00:00.000Z</published>
    <updated>2019-03-26T18:43:17.445Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="https://songkc.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://songkc.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
