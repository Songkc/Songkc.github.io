<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Songkc&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/6c8095f369fe745094e7e72f87054027</icon>
  <subtitle>Talk is cheap, show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://songkc.github.io/"/>
  <updated>2019-03-28T18:38:14.014Z</updated>
  <id>https://songkc.github.io/</id>
  
  <author>
    <name>Songkc</name>
    <email>weijia_sysu@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer - 删除链表中重复的结点</title>
    <link href="https://songkc.github.io/2019/03/24/%E5%89%91%E6%8C%87Offer-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/"/>
    <id>https://songkc.github.io/2019/03/24/剑指Offer-删除链表中重复的结点/</id>
    <published>2019-03-23T18:03:24.000Z</published>
    <updated>2019-03-28T18:38:14.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h3><p>使用三个指针，分别是指向当前结点的前一结点的指针 <strong>prev</strong>，指向当前结点的指针 <strong>curr</strong>，指向当前结点的后一结点的指针 <strong>latter</strong>，为了让第一个节点也有前一结点，定义一个 <strong>ListNode head</strong> 变量，其 <strong>next</strong> 值指向第一个结点。</p><p>接着从 <strong>curr</strong> 为第一个结点开始遍历，直到 <strong>latter</strong> 为 <strong>nullptr</strong>。</p><ul><li>遍历过程中如果 <strong>curr</strong> 与 <strong>latter</strong> 的值不同，则 <strong>prev, curr, latter</strong> 都往后移一个结点；</li><li>如果遇到 <strong>curr</strong> 和 <strong>latter</strong> 的值相同，就需要再进入一层循环，删除每一个与 <strong>curr</strong> 值相同的 <strong>latter</strong>，并将 <strong>latter</strong> 指向其自身的下一个，直到 <strong>latter</strong> 与 <strong>curr</strong> 的值不同或 <strong>latter</strong> 为 <strong>nullptr</strong> 则第二层循环结束，并将当前的 <strong>curr</strong> 结点也删除，然后 <strong>curr</strong> 指向当前 <strong>latter</strong> 的结点，<strong>prev-&gt;next</strong> 指向 <strong>curr</strong>，如果 <strong>latter</strong> 不为 <strong>nullptr</strong> 则 <strong>latter</strong> 指向当前 <strong>latter</strong> 的下一个结点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode head(0), *temp = nullptr;</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        ListNode *prev = &amp;head, *curr = pHead, *latter = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (latter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;val == latter-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">while</span> (latter != <span class="literal">nullptr</span> &amp;&amp; curr-&gt;val == latter-&gt;val) &#123;</span><br><span class="line">                    temp = latter;</span><br><span class="line">                    latter = latter-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = curr;</span><br><span class="line">                curr = latter;</span><br><span class="line">                prev-&gt;next = curr;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">if</span> (latter != <span class="literal">nullptr</span>) latter = latter-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = latter;</span><br><span class="line">                latter = latter-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>递归的主要思路是：判断当前结点与下一结点的值是否相同，如果不同则当前结点为不重复的一个结点，然后就是从当前结点指向的下一个结点开始找不重复的结点；如果当前结点与下一结点的值相同，那么就需要找到第一个与当前结点不同的结点，然后从这个结点开始再找不重复的结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode *node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;val != pHead-&gt;next-&gt;val) &#123;</span><br><span class="line">            node = pHead;</span><br><span class="line">            node-&gt;next = deleteDuplication(node-&gt;next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line">            node = pHead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;val == node-&gt;val) &#123;</span><br><span class="line">                temp = node;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> pHead;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 从第一个与当前结点不同的结点再次开始递归</span></span><br><span class="line">            node = deleteDuplication(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&amp;gt;2
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 142. Linked List Cycle II</title>
    <link href="https://songkc.github.io/2019/03/23/LeetCode-142-Linked-List-Cycle-II/"/>
    <id>https://songkc.github.io/2019/03/23/LeetCode-142-Linked-List-Cycle-II/</id>
    <published>2019-03-23T13:28:14.000Z</published>
    <updated>2019-03-29T18:28:18.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">Output: tail connects to node index <span class="number">1</span></span><br><span class="line">Explanation: There is a cycle in the linked <span class="built_in">list</span>, where tail connects to the</span><br><span class="line">second node.</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/circularlinkedlist_test1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output: tail connects to node index <span class="number">0</span></span><br><span class="line">Explanation: There is a cycle in the linked <span class="built_in">list</span>, where tail connects to the</span><br><span class="line">first node.</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/circularlinkedlist_test2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">Output: no cycle</span><br><span class="line">Explanation: There is no cycle in the linked <span class="built_in">list</span>.</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/circularlinkedlist_test3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="使用-stl-map"><a href="#使用-stl-map" class="headerlink" title="使用 stl::map"></a>使用 stl::map</h3><p><strong>map&lt;ListNode*, int&gt;</strong> 将 <strong>ListNode*</strong> 与 <strong>ListNode*</strong> 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 <strong>next</strong> 指向的 <strong>nullptr</strong> 时就会结束遍历，返回 <strong>nullptr</strong>；而如果单链表中存在环，第一个出现次数大于 <strong>1</strong> 的结点即环的入口结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; lmap;</span><br><span class="line">      ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lmap.count(node) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> (lmap[node] = <span class="number">1</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-stl-set"><a href="#使用-stl-set" class="headerlink" title="使用 stl::set"></a>使用 stl::set</h3><p>与使用 stl::map 的思路相似，故不再叙述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; nodeset;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeset.count(head) &gt; <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">            nodeset.insert(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><h3 id="使用快慢指针"><a href="#使用快慢指针" class="headerlink" title="使用快慢指针"></a>使用快慢指针</h3><p>设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。</p><p>此时，会出现两种情况：</p><ul><li><p>单链表中不存在环则：快指针往后遍历的过程中，会遍历到 <strong>nullptr</strong> 结点，即单链表中不存在环，最后一个结点指向的是 <strong>nullptr</strong>。</p></li><li><p>单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。</p><p><img src="/2019/03/23/LeetCode-142-Linked-List-Cycle-II/cycle.png" alt=""></p><ul><li><p>如果这时快指针已经是在环里走了 <strong>1</strong> 圈（对应于非环部分较短的情况）：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)</strong> 距离，<strong>2(x + d) = x + y + d</strong> ，可得 <strong>x = y - d</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。</p></li><li><p>如果这时快指针已经是在环里走了不止一圈，假设为 <strong>k</strong> 圈：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)​</strong> 距离，<strong>2(x + d) = x +ky + d​</strong>，可得 <strong>x = ky - d​</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      ListNode *slow = head, *fast = head;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">      fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细思路参考：<a href="https://www.cnblogs.com/zhuzhenwei918/p/7491892.html" target="_blank" rel="noopener">一个链表中包含环，请找出该链表的环的入口结点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given a linked list, return the no
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer - 链表中环的入口结点</title>
    <link href="https://songkc.github.io/2019/03/23/%E5%89%91%E6%8C%87Offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
    <id>https://songkc.github.io/2019/03/23/剑指Offer-链表中环的入口结点/</id>
    <published>2019-03-23T10:11:33.000Z</published>
    <updated>2019-03-26T19:20:26.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 <strong>NULL</strong>。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="使用-stl-map"><a href="#使用-stl-map" class="headerlink" title="使用 stl::map"></a>使用 stl::map</h3><p><strong>map&lt;ListNode*, int&gt;</strong> 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 <strong>next</strong> 指向的 <strong>nullptr</strong> 时就会结束遍历，返回 <strong>nullptr</strong>；而如果单链表中存在环，第一个出现次数大于 <strong>1</strong> 的结点即环的入口结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// method via stl::map</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; lmap;</span><br><span class="line">      ListNode *node = pHead;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lmap.count(node) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> (lmap[node] = <span class="number">1</span>);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-stl-set"><a href="#使用-stl-set" class="headerlink" title="使用 stl::set"></a>使用 stl::set</h3><p>与使用 stl::map 的思路相似，故不再叙述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// method via stl::set</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; nodeset;</span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeset.count(pHead) &gt; <span class="number">0</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">            nodeset.insert(pHead);</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用快慢指针"><a href="#使用快慢指针" class="headerlink" title="使用快慢指针"></a>使用快慢指针</h3><p>设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。</p><p>此时，会出现两种情况：</p><ul><li><p>单链表中不存在环则：快指针往后遍历的过程中，会遍历到 <strong>nullptr</strong> 结点，即单链表中不存在环，最后一个结点指向的是 <strong>nullptr</strong>。</p></li><li><p>单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。</p><p><img src="/2019/03/23/剑指Offer-链表中环的入口结点/cycle.png" alt=""></p><ul><li><p>如果这时快指针已经是在环里走了 <strong>1</strong> 圈（对应于非环部分较短的情况）：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)</strong> 距离，<strong>2(x + d) = x + y + d</strong> ，可得 <strong>x = y - d</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。</p></li><li><p>如果这时快指针已经是在环里走了不止一圈，假设为 <strong>k</strong> 圈：</p><p>此时快指针走了 <strong>2(x + d) (0 &lt;= d)​</strong> 距离，<strong>2(x + d) = x +ky + d​</strong>，可得 <strong>x = ky - d​</strong> ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// method via fast pointer and slow pointer</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      ListNode *slow = pHead, *fast = pHead;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">      fast = pHead;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细思路参考：<a href="https://www.cnblogs.com/zhuzhenwei918/p/7491892.html" target="_blank" rel="noopener">一个链表中包含环，请找出该链表的环的入口结点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 &lt;strong&gt;NULL&lt;/strong&gt;。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer - 二叉树的镜像</title>
    <link href="https://songkc.github.io/2019/03/22/%E5%89%91%E6%8C%87Offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>https://songkc.github.io/2019/03/22/剑指Offer-二叉树的镜像/</id>
    <published>2019-03-22T03:19:58.000Z</published>
    <updated>2019-03-26T19:07:39.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：</span><br><span class="line">             源二叉树                    镜像二叉树</span><br><span class="line">                8                          8 </span><br><span class="line">               /  \                       /  \</span><br><span class="line">              6   10                     10   6</span><br><span class="line">             / \  / \                   / \  / \</span><br><span class="line">            5  7  9 11                 11  9 7  5</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>对于每个二叉树结点都将左右子结点交换就可以，因此递归是最简短的形式，可以先继续递归左右子结点再交换左右子结点，也可以先交换左右子结点再继续递归左右子结点。</p><p>继续递归左右子结点时，可以先检查左右子结点是否为 <strong>nullptr</strong>，如果子结点是 <strong>nullptr</strong>，则不需要进行递归，可以减少内存空间和运行时间的消耗，因为递归需要为递归函数的参数和局部变量分配内存空间，同时还需要对递归函数进行压栈操作和递归函数执行及执行完后的出栈操作，这些都需要消耗时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (pRoot-&gt;left  != <span class="literal">nullptr</span>) Mirror(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pRoot-&gt;right != <span class="literal">nullptr</span>) Mirror(pRoot-&gt;right);</span><br><span class="line">        TreeNode* temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="stl-queue-非递归方法"><a href="#stl-queue-非递归方法" class="headerlink" title="stl::queue 非递归方法"></a>stl::queue 非递归方法</h3><p>通过队列以层次遍历的方式，遍历每一个二叉树结点，取出结点将左右子结点交换，再将非 <strong>nullptr</strong> 的子结点加入队列中，直到队列为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        TreeNode *node = <span class="literal">nullptr</span>, *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (que.empty() == <span class="literal">false</span>) &#123;</span><br><span class="line">            node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            temp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = temp;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left  != <span class="literal">nullptr</span>) que.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) que.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="stl-stack-非递归方法"><a href="#stl-stack-非递归方法" class="headerlink" title="stl::stack 非递归方法"></a>stl::stack 非递归方法</h3><p>与 stl::queue 的思路相似，故不再叙述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(pRoot);</span><br><span class="line">        TreeNode *node = <span class="literal">nullptr</span>, *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (stk.empty() == <span class="literal">false</span>) &#123;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            temp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = temp;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left  != <span class="literal">nullptr</span>) stk.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) stk.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。&lt;/p&gt;
&lt;h2 id=&quot;输入描述&quot;&gt;&lt;a href=&quot;#输入描述&quot; class
      
    
    </summary>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二叉树" scheme="https://songkc.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="剑指Offer" scheme="https://songkc.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>C++11 - 线程池</title>
    <link href="https://songkc.github.io/2019/02/27/C++11-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://songkc.github.io/2019/02/27/C++11-线程池/</id>
    <published>2019-02-26T17:47:39.000Z</published>
    <updated>2019-04-02T17:57:10.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><p>传统多线程方案中采用的服务器模型是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“<strong>即时创建，即时销毁</strong>”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。</p><p>线程池则是一种采用<strong>预创建技术</strong>的多线程处理形式，在程序启动之初就创建一定数量线程，运行过程中将任务添加到队列，然后再将任务分配给已创建好的线程中自动启动这些任务。因为程序边运行边创建线程是比较耗时的，所以我们通过池化的思想，减少创建线程和销毁线程对程序资源的消耗。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。</p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>线程池采用预创建的技术，在程序启动之后，将立即创建一定数量的线程（N1），放入空闲队列中。这些线程都是处于阻塞状态，不消耗 CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中执行。当 N1 个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。</p><p>使用线程完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。</p><p>线程池技术正是关注如何缩短或调整 T1，T3 时间的技术，从而提高服务器程序性能的。它把 T1，T3 分别安排在程序的启动和结束的时间段或者一些空闲的时间段，这样在程序处理多个任务时，就不会有 T1，T3 的开销了。同时，线程池不仅调整 T1 和 T3 产生的时间段，而且它还显著减少了创建线程的数目。</p><h2 id="线程池适合场景"><a href="#线程池适合场景" class="headerlink" title="线程池适合场景"></a>线程池适合场景</h2><p>事实上，线程池并不是万能的。它有其特定的使用场合。线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。</p><p>总之线程池通常适合下面的几个场合：</p><ol><li><strong>单位时间内处理任务频繁而且任务处理时间短。</strong></li><li><strong>对实时性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。</strong></li></ol><h2 id="线程池的组成部分"><a href="#线程池的组成部分" class="headerlink" title="线程池的组成部分"></a>线程池的组成部分</h2><ul><li>线程池管理器（ThreadPoolManager）：用于创建并管理线程</li><li>工作线程（WorkThread）：线程池中的线程</li><li>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行</li><li>任务队列（TaskQueue）：用于存放没有处理的任务</li></ul><h2 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h2><p>线程池管理一个任务队列，一个线程队列，然后每次取一个任务分配给一个线程去做，循环往复。而线程池一般要复用线程，所以如果是取一个 task 分配给某一个 thread，执行完之后再重新分配，在语言层面上基本都是不支持的：一般语言的 thread 都是执行一个固定的 task 函数，执行完毕线程也就结束了，因此要如何实现 task 和 thread 的分配呢？</p><p>思路就是：<strong>让每一个 thread 都去执行调度函数：循环获取一个 task，然后执行之。保证了 thread 函数的唯一性，而且复用线程执行 task。</strong></p><h2 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h2><h3 id="线程池代码"><a href="#线程池代码" class="headerlink" title="线程池代码"></a>线程池代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREADPOOL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADPOOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// constructor</span></span><br><span class="line">        ThreadPool(<span class="keyword">size_t</span> threadnum = <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// deconstructor</span></span><br><span class="line">        ~ThreadPool();</span><br><span class="line">        <span class="comment">// add task</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// the work threads</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; workers_;</span><br><span class="line">        <span class="comment">// the task queue</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks_;</span><br><span class="line">        <span class="comment">// the task queue lock</span></span><br><span class="line">        <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line">        <span class="comment">// condition variable</span></span><br><span class="line">        <span class="built_in">std</span>::condition_variable condition_;</span><br><span class="line">        <span class="comment">// constrol thread pool</span></span><br><span class="line">        <span class="keyword">bool</span> stop_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::ThreadPool(<span class="keyword">size_t</span> threadnum) : stop_(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadnum; ++i) &#123;</span><br><span class="line">        workers_.emplace_back( [<span class="keyword">this</span>]&#123;  <span class="comment">// 为每个线程构造一个调度函数</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task;</span><br><span class="line">                &#123;   <span class="comment">// 此处花括号使得在执行 task 前即释放互斥锁</span></span><br><span class="line">                    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;mutex_);</span><br><span class="line">                    <span class="comment">// stop_ 为 false 且 task queue 为空时阻塞线程，其他情况都不阻塞</span></span><br><span class="line">                    <span class="keyword">this</span>-&gt;condition_.wait(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">                        <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;stop_ || !<span class="keyword">this</span>-&gt;tasks_.empty()); &#125;);</span><br><span class="line">                    <span class="comment">// 线程结束，用于销毁线程</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop_ &amp;&amp; <span class="keyword">this</span>-&gt;tasks_.empty())</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;tasks_.empty() == <span class="literal">false</span>) &#123;</span><br><span class="line">                        task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks_.front());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks_.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                task();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~ThreadPool() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对于所有线程共享的变量操作前都需要加锁</span></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex_);</span><br><span class="line">        stop_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒所有阻塞的线程</span></span><br><span class="line">    condition_.notify_all();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::thread &amp;worker : workers_) &#123;</span><br><span class="line">        <span class="comment">// 等待所有线程都执行完</span></span><br><span class="line">        worker.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new task to the task queue</span></span><br><span class="line"><span class="keyword">bool</span> ThreadPool::EnQueue(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对于 task queue 的操作都需要加锁，因为 task queue 是所有线程共有的</span></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex_);</span><br><span class="line">        tasks_.emplace(task);</span><br><span class="line">    &#125;</span><br><span class="line">    condition_.notify_one();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _THREADPOOL_H_</span></span></span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"threadpool.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process_to_test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; i; ++x) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; j; ++y) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread num: "</span> &lt;&lt; -(i - <span class="number">8</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        pool.EnQueue(<span class="built_in">std</span>::bind(&amp;Test::process_to_test, &amp;test, <span class="number">8</span> - i, <span class="number">1000000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Progschj/ThreadPool：<a href="https://github.com/progschj/ThreadPool" target="_blank" rel="noopener">https://github.com/progschj/ThreadPool</a></li><li>C++11线程池实现：<a href="https://blog.csdn.net/zdarks/article/details/46994607" target="_blank" rel="noopener">https://blog.csdn.net/zdarks/article/details/46994607</a></li><li>线程池的原理及实现：<a href="https://blog.csdn.net/Hsuxu/article/details/8985931" target="_blank" rel="noopener">https://blog.csdn.net/Hsuxu/article/details/8985931</a></li><li>基于c++11的100行实现简单线程池：<a href="https://blog.csdn.net/gcola007/article/details/78750220" target="_blank" rel="noopener">https://blog.csdn.net/gcola007/article/details/78750220</a></li><li>C++11并发学习之六：线程池的实现：<a href="https://blog.csdn.net/caoshangpa/article/details/80374651" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/80374651</a></li><li>使用C++11实现线程池的两种方法：<a href="https://blog.csdn.net/liushengxi_root/article/details/83932654" target="_blank" rel="noopener">https://blog.csdn.net/liushengxi_root/article/details/83932654</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是线程池？&quot;&gt;&lt;a href=&quot;#什么是线程池？&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池？&quot;&gt;&lt;/a&gt;什么是线程池？&lt;/h2&gt;&lt;p&gt;传统多线程方案中采用的服务器模型是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行
      
    
    </summary>
    
      <category term="C++" scheme="https://songkc.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://songkc.github.io/tags/C/"/>
    
      <category term="C++11" scheme="https://songkc.github.io/tags/C-11/"/>
    
      <category term="并发编程" scheme="https://songkc.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++11 - Lambda 表达式</title>
    <link href="https://songkc.github.io/2018/12/29/C++11-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://songkc.github.io/2018/12/29/C++11-Lambda表达式/</id>
    <published>2018-12-29T09:01:42.000Z</published>
    <updated>2019-03-31T18:56:22.652Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 的一大亮点就是引入了 Lambda 表达式。利用 Lambda 表达式，可以方便的定义和创建匿名函数。</p><h2 id="声明-Lambda-表达式"><a href="#声明-Lambda-表达式" class="headerlink" title="声明 Lambda 表达式"></a>声明 Lambda 表达式</h2><p>Lambda 表达式完整的声明格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><p>各项具体含义如下：</p><ol><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ol><p>此外，我们还可以省略其中的某些成分来声明“不完整”的 Lambda 表达式，常见的有以下几种：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">格式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">[capture list] (params list) -&gt; return type { function body }</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">[capture list] (params list) { function body }</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">[capture list] { function body }</td></tr></tbody></table><ul><li>格式 1 声明了 <strong>const</strong> 类型的表达式，这种类型的表达式不能修改捕获列表中的值。</li><li>格式 2 省略了返回值类型，但编译器可以根据以下规则推断出 Lambda 表达式的返回类型：<ul><li>如果 function body 中没有 <strong>return</strong> 语句，则返回值为 <strong>void</strong> 类型；</li><li>如果 function body 中存在 <strong>return</strong> 语句，则该 Lambda 表达式的返回类型由 <strong>return</strong> 语句的返回类型确定。</li></ul></li><li>格式 3 中省略了参数列表，类似普通函数中的无参函数。</li></ul><h2 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a>捕获外部变量</h2><p>Lambda 表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该 Lambda 表达式使用）。那么，在哪里指定这些外部变量呢？Lambda 表达式通过在最前面的方括号 <code>[]</code> 来明确指明其内部可以访问的外部变量，这一过程也称作 Lambda 表达式“捕获”了外部变量。</p><p>通过一个例子来直观地说明一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;; </span><br><span class="line">    f();  <span class="comment">// 输出：123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或通过“函数体”后面的‘()’传入参数</span></span><br><span class="line">    <span class="keyword">auto</span> x = [](<span class="keyword">int</span> a)&#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;(<span class="number">123</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子先声明了一个整型变量 <strong>a</strong>，然后再创建 Lambda 表达式，该表达式“捕获”了变量 <strong>a</strong>，这样在 Lambda 表达式函数体中就可以获得该变量的值。</p><p>类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。</p><h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>值捕获和参数传递中的值传递类似，被捕获的变量的值在 Lambda 表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响 Lambda 表达式中的值。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    f();  <span class="comment">// 输出：123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，如果以传值方式捕获外部变量，则在 Lambda 表达式函数体中不能修改该外部变量的值。</p><h3 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h3><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符 <code>&amp;</code>。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    f();  <span class="comment">// 输出：321</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。</p><h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>上面的<strong>值捕获</strong>和<strong>引用捕获</strong>都需要我们在捕获列表中显式列出 Lambda 表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为<strong>隐式捕获</strong>。隐式捕获有两种方式，分别是 <code>[=]</code> 和 <code>[&amp;]</code>。<code>[=]</code> 表示以值捕获的方式捕获外部变量，<code>[&amp;]</code> 表示以引用捕获的方式捕获外部变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;      <span class="comment">// 隐式值捕获</span></span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    f();    <span class="comment">// 输出：123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;] &#123; <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;;   <span class="comment">// 隐式引用捕获</span></span><br><span class="line">    b = <span class="number">321</span>;</span><br><span class="line">    func();  <span class="comment">// 输出：321</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h3><p>上面的例子，要么是值捕获，要么是引用捕获，Lambda 表达式还支持混合的方式捕获外部变量，混合方式主要是以上几种捕获方式的组合使用。</p><p>总结一下，C++11 中的 Lambda 表达式捕获外部变量主要有以下形式：</p><table><thead><tr><th style="text-align:center">捕获形式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">[]</td><td style="text-align:center">不捕获任何外部变量</td></tr><tr><td style="text-align:center">[变量名, …]</td><td style="text-align:center">默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td style="text-align:center">[this]</td><td style="text-align:center">以值的形式捕获this指针</td></tr><tr><td style="text-align:center">[=]</td><td style="text-align:center">以值的形式捕获所有外部变量</td></tr><tr><td style="text-align:center">[&amp;]</td><td style="text-align:center">以引用形式捕获所有外部变量</td></tr><tr><td style="text-align:center">[=, &amp;x]</td><td style="text-align:center">变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td style="text-align:center">[&amp;, x]</td><td style="text-align:center">变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><h2 id="修改捕获变量"><a href="#修改捕获变量" class="headerlink" title="修改捕获变量"></a>修改捕获变量</h2><p>前面我们提到过，在 Lambda 表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用 <strong>mutable</strong> 关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; <span class="built_in">cout</span> &lt;&lt; ++a; &#125;;  <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出：123</span></span><br><span class="line">    f();  <span class="comment">// 输出：124</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda-表达式的参数"><a href="#Lambda-表达式的参数" class="headerlink" title="Lambda 表达式的参数"></a>Lambda 表达式的参数</h2><p>Lambda 表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在 Lambda 表达式中传递参数还有一些限制，主要有以下几点：</p><ol><li>参数列表中不能有默认参数</li><li>不支持可变参数</li><li>所有参数必须有参数名</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++11 的一大亮点就是引入了 Lambda 表达式。利用 Lambda 表达式，可以方便的定义和创建匿名函数。&lt;/p&gt;
&lt;h2 id=&quot;声明-Lambda-表达式&quot;&gt;&lt;a href=&quot;#声明-Lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;声
      
    
    </summary>
    
      <category term="C++" scheme="https://songkc.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://songkc.github.io/tags/C/"/>
    
      <category term="C++11" scheme="https://songkc.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 671. Second Minimum Node in a Binary Tree</title>
    <link href="https://songkc.github.io/2018/10/15/LeetCode-671-Second-Minimum-Node-In-a-Binary-Tree/"/>
    <id>https://songkc.github.io/2018/10/15/LeetCode-671-Second-Minimum-Node-In-a-Binary-Tree/</id>
    <published>2018-10-15T02:01:22.000Z</published>
    <updated>2019-03-29T18:40:20.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes.</p><p>Given such a binary tree, you need to output the <strong>second minimum</strong> value in the set made of all the nodes’ value in the whole tree.</p><p>If no such second minimum value exists, output -1 instead.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 1</span></span><br><span class="line">Input:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">5</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: The smallest value is <span class="number">2</span>, the second smallest value is <span class="number">5.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 2</span></span><br><span class="line">Input:</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Output: <span class="number">-1</span></span><br><span class="line">Explanation: The smallest value is <span class="number">2</span>, but there isn't any second smallest value.</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由题意可知，父节点的值一定小于等于两个子节点的值，因而根节点的值一定是最小值，那么可以推导出值第二小的节点在根节点的左子树中或在根节点的右子树中或不存在，同时，当一个节点的值大于根节点的值(即最小值)时，由于父节点的值一定小于等于两个子节点的值，那么由该节点衍生的子树的节点的值一定大于等于该节点的值，因此该节点衍生的子树并不需要检查。</p><p>解决的方法有多种，这里我使用了 BFS（广度优先搜索）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// unrecursion by BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">int</span> min = root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> left, right, smin = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            TreeNode* temp = que.front();</span><br><span class="line">            <span class="keyword">if</span> (min &lt; temp-&gt;val) &#123;</span><br><span class="line">                smin = (smin &gt; temp-&gt;val ? temp-&gt;val : smin);</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;left != <span class="literal">NULL</span> &amp;&amp; temp-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                que.push(temp-&gt;left);</span><br><span class="line">                que.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> smin == INT_MAX ? <span class="number">-1</span> : smin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>学习了一下 LeetCode 上讨论区的做法，将递归和分治的做法也写出来。</p><h3 id="Recursion-Method（递归方法）"><a href="#Recursion-Method（递归方法）" class="headerlink" title="Recursion Method（递归方法）"></a>Recursion Method（递归方法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> findSecMin(root, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecMin</span><span class="params">(TreeNode* node, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &gt; first) <span class="keyword">return</span> node-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = findSecMin(node-&gt;left, first);</span><br><span class="line">        <span class="keyword">int</span> right = findSecMin(node-&gt;right, first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="number">-1</span> &amp;&amp; left == <span class="number">-1</span>) <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Divide-and-Conquer-Method-（分治方法）"><a href="#Divide-and-Conquer-Method-（分治方法）" class="headerlink" title="Divide and Conquer Method （分治方法）"></a>Divide and Conquer Method （分治方法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// divide and conquer</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> right = root-&gt;right-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == root-&gt;val)</span><br><span class="line">            left = findSecondMinimumValue(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (right == root-&gt;val)</span><br><span class="line">            right = findSecondMinimumValue(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span> &amp;&amp; right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left &gt; right ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given a non-empty special binary t
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="二叉树" scheme="https://songkc.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 32. Longest Valid Parentheses</title>
    <link href="https://songkc.github.io/2018/10/11/LeetCode-32-Longest-Valid-Parentheses/"/>
    <id>https://songkc.github.io/2018/10/11/LeetCode-32-Longest-Valid-Parentheses/</id>
    <published>2018-10-11T06:41:29.000Z</published>
    <updated>2019-03-29T18:36:28.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For <span class="string">"(()"</span>, the longest valid parentheses substring is <span class="string">"()"</span>, which has</span><br><span class="line">length = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">Another example is <span class="string">")()())"</span>, where the longest valid parentheses</span><br><span class="line">substring is <span class="string">"()()"</span>, which has length = <span class="number">4.</span></span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一开始只是简单的以为是求出所有合法的圆括号的数量，就直接用一个<strong>栈</strong>去写，提交后才发现理解错了，原来题目的意思是从找出字符串中最长的合法圆括号子串的长度。</p><p>重新审题后就能发现每个合法的字串其实都是由不合法的字串分隔开的，我的思路是用一个栈存储 <code>pair&lt;char, int&gt;</code> 类型的元素，<strong>char</strong> 为圆括号字符，<strong>int</strong> 为此时所有合法的圆括号数量。当栈顶元素字符为 <strong>‘(‘</strong> 且当前字符为 <strong>‘)’</strong> 时，就将栈顶元素 <strong>pop</strong> 出，并将合法圆括号数量 <strong>+2</strong>，到最后栈中留下的都是不合法的圆括号，其实就相当于将合法的圆括号字串分隔开的分隔符，此时就可以利用这些分隔符求出每个合法圆括号字串的长度，取最大的字串长度即可。算法的复杂度是 $O(n^2)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &gt; stk;</span><br><span class="line">        pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; p(s[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        stk.push(p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; temp(s[i], count);</span><br><span class="line">                stk.push(temp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; top = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (top.first == <span class="string">'('</span> &amp;&amp; s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                count += <span class="number">2</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; temp(s[i], count);</span><br><span class="line">                stk.push(temp);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; top = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (top.second == count) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = count - top.second;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; temp) max = temp;</span><br><span class="line">            count -= temp;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; count) max = count;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><h3 id="精简代码"><a href="#精简代码" class="headerlink" title="精简代码"></a>精简代码</h3><p>LeetCode 讨论区发现，许多解答思路与我的思路是一样的，但我的代码显得有些冗余了，附上精简后的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            temp = stk.top();</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="number">-1</span> &amp;&amp; s[i] == <span class="string">')'</span> &amp;&amp; s[temp] == <span class="string">'('</span>) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                maxL = max(maxL, i - stk.top());</span><br><span class="line">            &#125; <span class="keyword">else</span> stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>还有用使用动态规划（DP）算法来解题的思路，这里也在此附上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *V = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) ++open;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">')'</span> &amp;&amp; open &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// matches found</span></span><br><span class="line">                V[i] = V[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// add matches from previous</span></span><br><span class="line">                <span class="keyword">if</span> (i - V[i] &gt; <span class="number">0</span>) V[i] += V[i - V[i]];</span><br><span class="line"></span><br><span class="line">                --open;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (V[i] &gt; max) max = V[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> V;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Given a string containing ju
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://songkc.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="动态规划" scheme="https://songkc.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 551. Student Attendance Record I</title>
    <link href="https://songkc.github.io/2018/10/05/LeetCode-551-Student-Attendence-Record-I/"/>
    <id>https://songkc.github.io/2018/10/05/LeetCode-551-Student-Attendence-Record-I/</id>
    <published>2018-10-05T01:02:33.000Z</published>
    <updated>2019-03-28T18:49:27.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>You are given a string representing an attendance record for a student. The record only contains the following three characters:</p><ol><li><strong>‘A’</strong> : Absent.</li><li><strong>‘L’</strong> : Late.</li><li><strong>‘P’</strong> : Present.</li></ol><p>A student could be rewarded if his attendance record doesn’t contain <strong>more than one ‘A’ (absent)</strong> or <strong>more than two continuous ‘L’ (late)</strong>.</p><p>You need to return whether the student could be rewarded according to his attendance record.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"PPALLP"</span></span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"PPALLL"</span></span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先分析题目，根据题目的意思是说，只要缺勤超过两次或者迟到超过两次且是连续的就应该返回 <strong>false</strong>，缺勤超过两次这个直接记录就 OK，而这题的重点用更通俗的话来讲就是连续两天以上迟到，其实最简单的做法就是用一个变量 <code>late</code> 记录迟到的次数，迟到则加 <strong>1</strong>，不是迟到的则将 <strong>late</strong> 重置为 <strong>0</strong>，然后判断 <strong>late</strong> 是否大于 <strong>2</strong> 即可。这题算是比较简单的，巧妙的 <strong>if-else</strong> 就可以做出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkRecord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">abs</span> = <span class="number">0</span>, late = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'A'</span>) <span class="built_in">abs</span>++;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'L'</span>) late++;</span><br><span class="line">            <span class="keyword">else</span> late = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span> &gt; <span class="number">1</span> || late &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;You are given a string representin
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="https://songkc.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 48. Rotate Image</title>
    <link href="https://songkc.github.io/2018/09/30/LeetCode-48-Rotate-Image/"/>
    <id>https://songkc.github.io/2018/09/30/LeetCode-48-Rotate-Image/</id>
    <published>2018-09-30T11:54:52.000Z</published>
    <updated>2019-03-29T18:29:24.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</li><li>Rotate the image by 90 degrees (clockwise).</li></ul><p><strong>Note:</strong> You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>问题主要在于不能使用额外的2维矩阵去求解，思路其实就是由内圈到外圈将整个矩阵顺时针旋转 90°，一是存放当前位置的值以便旋转后将值赋值到旋转后的新位置，二是推导出从当前位置到旋转后的新位置的公式，上述一二操作循环四个数字即可。整个算法的时间复杂度是 $O(n^2)​$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; matrix.size() - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                row = i; col = j;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; ++k) &#123;</span><br><span class="line">                    tmp = matrix[row][col];</span><br><span class="line">                    matrix[row][col] = temp;</span><br><span class="line">                    temp = row;</span><br><span class="line">                    row = col;</span><br><span class="line">                    col = matrix.size() - <span class="number">1</span> - temp;</span><br><span class="line">                    temp = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  n represents the matrix's dimension</span></span><br><span class="line"><span class="comment">  row represents the row of the present position</span></span><br><span class="line"><span class="comment">  col represents the column of the present position</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Actually, the transform function can be written as:</span></span><br><span class="line"><span class="comment">  new_row = col</span></span><br><span class="line"><span class="comment">  new_col = n - row - 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Example:</span></span><br><span class="line"><span class="comment">  1 2 3        7 2 1        7 4 1</span></span><br><span class="line"><span class="comment">  4 5 6   -&gt;   4 5 6   -&gt;   8 5 2</span></span><br><span class="line"><span class="comment">  7 8 9       9 8 3        9 6 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>LeetCode 讨论区上见到的，先将矩阵按主对角线翻转，再将翻转后的矩阵的每一行进行逆序，就可以完成对矩阵的 90° 旋转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = m.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                swap(m[i][j], m[j][i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            reverse(m[i].begin(), m[i].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Example:</span></span><br><span class="line"><span class="comment">  1 2 3        1 4 7        7 4 1</span></span><br><span class="line"><span class="comment">  4 5 6   -&gt;   2 5 8   -&gt;   8 5 2</span></span><br><span class="line"><span class="comment">  7 8 9       3 6 9        9 6 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;You are given an &lt;em&gt;n&lt;/em&gt; 
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://songkc.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 21. Merge Two Sorted Lists</title>
    <link href="https://songkc.github.io/2018/09/25/LeetCode-21-Merge-Two-Sorted-Lists/"/>
    <id>https://songkc.github.io/2018/09/25/LeetCode-21-Merge-Two-Sorted-Lists/</id>
    <published>2018-09-25T05:14:51.000Z</published>
    <updated>2019-03-29T18:29:01.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>合并两个已按小到大排序的链表，最简单的做法就是新建一个链表，然后比较原有的两个链表当前节点的大小，然后选择较小的节点加到新建链表上，接着将被选中的链表的节点指向他的下一个，重复以上，知道某个链表已读到末尾或两个链表都为空，然后将未读完的链表的节点直接加到新建链表上就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                node-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = (l1 == <span class="literal">NULL</span> ? l2 : l1);</span><br><span class="line">        node = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>还可以通过递归实现，原理与上面相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* node;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            node = l1;</span><br><span class="line">            node-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = l1;</span><br><span class="line">            node-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Merge two sorted linked list
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 2. Add Two Numbers</title>
    <link href="https://songkc.github.io/2018/09/19/LeetCode-2-Add-Two-Numbers/"/>
    <id>https://songkc.github.io/2018/09/19/LeetCode-2-Add-Two-Numbers/</id>
    <published>2018-09-19T02:58:21.000Z</published>
    <updated>2019-03-29T18:28:35.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><ul><li>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</li><li>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">  </span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目挺简单的，就是通过链表实现大数加法，结果的每一位由三个值决定，两个是两个加数在这个数位上的值，剩下一个是上一位的进位，主要就是需要注意进位的实现，也没什么难度，可能还有需要注意的就是代码的逻辑需要简明清晰，不然很容易写的很冗长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, tmp = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *p1 = l1, *p2 = l2, *temp = <span class="literal">NULL</span>, *result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span> || p2 != <span class="literal">NULL</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            n1 = (p1 != <span class="literal">NULL</span>) ? p1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            n2 = (p2 != <span class="literal">NULL</span>) ? p2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">NULL</span>) result = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span> temp-&gt;next = <span class="keyword">new</span> ListNode(tmp % <span class="number">10</span>);</span><br><span class="line">            p1 = (p1 == <span class="literal">NULL</span>) ? p1 : p1-&gt;next;</span><br><span class="line">            p2 = (p2 == <span class="literal">NULL</span>) ? p2 : p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) temp = result;</span><br><span class="line">            <span class="keyword">else</span> temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>在 LeetCode 讨论区中发现了更简洁的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    ListNode preHead(0), *p = &amp;preHead;</span><br><span class="line">    <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || extra) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + extra;</span><br><span class="line">        extra = sum / <span class="number">10</span>;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">        l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;You are given two &lt;strong&gt;no
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="https://songkc.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 1. Two Sum</title>
    <link href="https://songkc.github.io/2018/09/12/LeetCode-1-Two-Sum/"/>
    <id>https://songkc.github.io/2018/09/12/LeetCode-1-Two-Sum/</id>
    <published>2018-09-12T14:20:34.000Z</published>
    <updated>2019-03-27T17:58:10.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一开始，我想到用 <strong>stl::map</strong> 来解决，数组元素值作为 <strong>map</strong> 的键，下标则是作为对应的值。将 <strong>target</strong> 减去当前元素值，看 <strong>map</strong> 中是否存在差值的键值，如果存在就说明找到了，不存在则将当前元素值和对应下标存入 <strong>map</strong> 中，以便后面的元素能对应。</p><p>但是，我发现如果出现目标是一个元素的两倍，那么输出的结果将是两次那个元素的下标。为了解决这个情况，我调整了一下语句的顺序，将对 <strong>map</strong> 赋值的语句放到查找后，这样就不会出现上面所说的问题了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.g</span></span><br><span class="line">intput: [<span class="number">2</span> <span class="number">4</span> <span class="number">4</span> <span class="number">7</span> <span class="number">10</span>], target = <span class="number">8</span></span><br><span class="line">output: [<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; reflect;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reflect.find(target - nums[i]) != reflect.end()) &#123;</span><br><span class="line">                result.push_back(reflect[target - nums[i]]);</span><br><span class="line">                result.push_back(reflect[nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            reflect[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;Given an array of integers, return
      
    
    </summary>
    
      <category term="LeetCode" scheme="https://songkc.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://songkc.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://songkc.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="https://songkc.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://songkc.github.io/2018/09/01/hello-world/"/>
    <id>https://songkc.github.io/2018/09/01/hello-world/</id>
    <published>2018-09-01T04:00:00.000Z</published>
    <updated>2019-03-26T18:43:17.445Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="https://songkc.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://songkc.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
