[{"title":"剑指Offer - 删除链表中重复的结点","date":"2019-03-23T18:03:24.000Z","path":"2019/03/24/剑指Offer-删除链表中重复的结点/","text":"题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; &#125;&#125;; 解答非递归方法使用三个指针，分别是指向当前结点的前一结点的指针 prev，指向当前结点的指针 curr，指向当前结点的后一结点的指针 latter，为了让第一个节点也有前一结点，定义一个 ListNode head 变量，其 next 值指向第一个结点。 接着从 curr 为第一个结点开始遍历，直到 latter 为 nullptr。 遍历过程中如果 curr 与 latter 的值不同，则 prev, curr, latter 都往后移一个结点； 如果遇到 curr 和 latter 的值相同，就需要再进入一层循环，删除每一个与 curr 值相同的 latter，并将 latter 指向其自身的下一个，直到 latter 与 curr 的值不同或 latter 为 nullptr 则第二层循环结束，并将当前的 curr 结点也删除，然后 curr 指向当前 latter 的结点，prev-&gt;next 指向 curr，如果 latter 不为 nullptr 则 latter 指向当前 latter 的下一个结点。 1234567891011121314151617181920212223242526272829303132333435363738/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == nullptr) return pHead; ListNode head(0), *temp = nullptr; head.next = pHead; ListNode *prev = &amp;head, *curr = pHead, *latter = pHead-&gt;next; while (latter != nullptr) &#123; if (curr-&gt;val == latter-&gt;val) &#123; while (latter != nullptr &amp;&amp; curr-&gt;val == latter-&gt;val) &#123; temp = latter; latter = latter-&gt;next; delete temp; &#125; temp = curr; curr = latter; prev-&gt;next = curr; delete temp; if (latter != nullptr) latter = latter-&gt;next; &#125; else &#123; prev = curr; curr = latter; latter = latter-&gt;next; &#125; &#125; return head.next; &#125;&#125;; 递归方法递归的主要思路是：判断当前结点与下一结点的值是否相同，如果不同则当前结点为不重复的一个结点，然后就是从当前结点指向的下一个结点开始找不重复的结点；如果当前结点与下一结点的值相同，那么就需要找到第一个与当前结点不同的结点，然后从这个结点开始再找不重复的结点。 1234567891011121314151617181920212223242526272829303132333435/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; if (pHead-&gt;next == nullptr) return pHead; ListNode *node = nullptr; if (pHead-&gt;val != pHead-&gt;next-&gt;val) &#123; node = pHead; node-&gt;next = deleteDuplication(node-&gt;next); &#125; else &#123; ListNode *temp = nullptr; node = pHead-&gt;next; while (node != nullptr &amp;&amp; pHead-&gt;val == node-&gt;val) &#123; temp = node; node = node-&gt;next; delete temp; &#125; delete pHead; if (node == nullptr) return nullptr; // 从第一个与当前结点不同的结点再次开始递归 node = deleteDuplication(node); &#125; return node; &#125;&#125;;","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"LeetCode - 142. Linked List Cycle II","date":"2019-03-23T13:28:14.000Z","path":"2019/03/23/LeetCode-142-Linked-List-Cycle-II/","text":"DescriptionGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. ExampleExample 11234Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to thesecond node. Example 21234Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to thefirst node. Example 3123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; &#125;&#125;; Solution使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = head; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (head != nullptr) &#123; if (nodeset.count(head) &gt; 0) return head; nodeset.insert(head); head = head-&gt;next; &#125; return nullptr; &#125;&#125;; Improvement使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; ListNode *slow = head, *fast = head; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = head; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"剑指Offer - 链表中环的入口结点","date":"2019-03-23T10:11:33.000Z","path":"2019/03/23/剑指Offer-链表中环的入口结点/","text":"题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 NULL。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; &#125;&#125;; 解答使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122232425/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::map ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = pHead; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021222324/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::set ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (pHead != nullptr) &#123; if (nodeset.count(pHead) &gt; 0) return pHead; nodeset.insert(pHead); pHead = pHead-&gt;next; &#125; return nullptr; &#125;&#125;; 使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829303132/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via fast pointer and slow pointer ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; ListNode *slow = pHead, *fast = pHead; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = pHead; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"剑指Offer - 二叉树的镜像","date":"2019-03-22T03:19:58.000Z","path":"2019/03/22/剑指Offer-二叉树的镜像/","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述1234567二叉树的镜像定义： 源二叉树 镜像二叉树 8 8 / \\ / \\ 6 10 10 6 / \\ / \\ / \\ / \\ 5 7 9 11 11 9 7 5 接口123456789101112131415/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; &#125;&#125;; 解答递归方法对于每个二叉树结点都将左右子结点交换就可以，因此递归是最简短的形式，可以先继续递归左右子结点再交换左右子结点，也可以先交换左右子结点再继续递归左右子结点。 继续递归左右子结点时，可以先检查左右子结点是否为 nullptr，如果子结点是 nullptr，则不需要进行递归，可以减少内存空间和运行时间的消耗，因为递归需要为递归函数的参数和局部变量分配内存空间，同时还需要对递归函数进行压栈操作和递归函数执行及执行完后的出栈操作，这些都需要消耗时间。 1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; if (pRoot-&gt;left != nullptr) Mirror(pRoot-&gt;left); if (pRoot-&gt;right != nullptr) Mirror(pRoot-&gt;right); TreeNode* temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; &#125;&#125;; stl::queue 非递归方法通过队列以层次遍历的方式，遍历每一个二叉树结点，取出结点将左右子结点交换，再将非 nullptr 的子结点加入队列中，直到队列为空。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; queue&lt;TreeNode*&gt; que; que.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (que.empty() == false) &#123; node = que.front(); que.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) que.push(node-&gt;left); if (node-&gt;right != nullptr) que.push(node-&gt;right); &#125; &#125;&#125;; stl::stack 非递归方法与 stl::queue 的思路相似，故不再叙述。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; stack&lt;TreeNode*&gt; stk; stk.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (stk.empty() == false) &#123; node = stk.top(); stk.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) stk.push(node-&gt;left); if (node-&gt;right != nullptr) stk.push(node-&gt;right); &#125; &#125;&#125;;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://songkc.github.io/tags/二叉树/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"C++11 - 线程池","date":"2019-02-26T17:47:39.000Z","path":"2019/02/27/C++11-线程池/","text":"什么是线程池？传统多线程方案中采用的服务器模型是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。 线程池则是一种采用预创建技术的多线程处理形式，在程序启动之初就创建一定数量线程，运行过程中将任务添加到队列，然后再将任务分配给已创建好的线程中自动启动这些任务。因为程序边运行边创建线程是比较耗时的，所以我们通过池化的思想，减少创建线程和销毁线程对程序资源的消耗。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。 线程池原理线程池采用预创建的技术，在程序启动之后，将立即创建一定数量的线程（N1），放入空闲队列中。这些线程都是处于阻塞状态，不消耗 CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中执行。当 N1 个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。 使用线程完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。 线程池技术正是关注如何缩短或调整 T1，T3 时间的技术，从而提高服务器程序性能的。它把 T1，T3 分别安排在程序的启动和结束的时间段或者一些空闲的时间段，这样在程序处理多个任务时，就不会有 T1，T3 的开销了。同时，线程池不仅调整 T1 和 T3 产生的时间段，而且它还显著减少了创建线程的数目。 线程池适合场景事实上，线程池并不是万能的。它有其特定的使用场合。线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。 总之线程池通常适合下面的几个场合： 单位时间内处理任务频繁而且任务处理时间短。 对实时性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。 线程池的组成部分 线程池管理器（ThreadPoolManager）：用于创建并管理线程 工作线程（WorkThread）：线程池中的线程 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行 任务队列（TaskQueue）：用于存放没有处理的任务 线程池实现原理线程池管理一个任务队列，一个线程队列，然后每次取一个任务分配给一个线程去做，循环往复。而线程池一般要复用线程，所以如果是取一个 task 分配给某一个 thread，执行完之后再重新分配，在语言层面上基本都是不支持的：一般语言的 thread 都是执行一个固定的 task 函数，执行完毕线程也就结束了，因此要如何实现 task 和 thread 的分配呢？ 思路就是：让每一个 thread 都去执行调度函数：循环获取一个 task，然后执行之。保证了 thread 函数的唯一性，而且复用线程执行 task。 线程池实现线程池代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#ifndef THREADPOOL_H_#define THREADPOOL_H_#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;class ThreadPool &#123; public: // constructor ThreadPool(size_t threadnum = 1); // deconstructor ~ThreadPool(); // add task bool EnQueue(std::function&lt;void()&gt;); private: // the work threads std::vector&lt;std::thread&gt; workers_; // the task queue std::queue&lt;std::function&lt;void()&gt;&gt; tasks_; // the task queue lock std::mutex mutex_; // condition variable std::condition_variable condition_; // constrol thread pool bool stop_;&#125;;// the constructor just launches some amount of workersinline ThreadPool::ThreadPool(size_t threadnum) : stop_(false) &#123; for (size_t i = 0; i &lt; threadnum; ++i) &#123; workers_.emplace_back( [this]&#123; // 为每个线程构造一个调度函数 while (1) &#123; std::function&lt;void()&gt; task; &#123; // 此处花括号使得在执行 task 前即释放互斥锁 std::unique_lock&lt;std::mutex&gt; lock(this-&gt;mutex_); // stop_ 为 false 且 task queue 为空时阻塞线程，其他情况都不阻塞 this-&gt;condition_.wait(lock, [this]&#123; return (this-&gt;stop_ || !this-&gt;tasks_.empty()); &#125;); // 线程结束，用于销毁线程 if (this-&gt;stop_ &amp;&amp; this-&gt;tasks_.empty()) return; if (this-&gt;tasks_.empty() == false) &#123; task = std::move(this-&gt;tasks_.front()); this-&gt;tasks_.pop(); &#125; &#125; task(); &#125; &#125;); &#125;&#125;// the destructor joins all threadsinline ThreadPool::~ThreadPool() &#123; &#123; // 对于所有线程共享的变量操作前都需要加锁 std::unique_lock&lt;std::mutex&gt; lock(mutex_); stop_ = true; &#125; // 唤醒所有阻塞的线程 condition_.notify_all(); for (std::thread &amp;worker : workers_) &#123; // 等待所有线程都执行完 worker.join(); &#125;&#125;// add new task to the task queuebool ThreadPool::EnQueue(std::function&lt;void()&gt; task) &#123; &#123; // 对于 task queue 的操作都需要加锁，因为 task queue 是所有线程共有的 std::unique_lock&lt;std::mutex&gt; lock(mutex_); tasks_.emplace(task); &#125; condition_.notify_one(); return true;&#125;#endif // _THREADPOOL_H_ 测试代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include \"threadpool.h\"using std::cout;using std::endl;class Test &#123; public: void process_to_test(const int i, const int j) &#123; int count = 0; for (int x = 0; x &lt; i; ++x) &#123; for (int y = 0; y &lt; j; ++y) &#123; ++count; &#125; &#125; cout &lt;&lt; \"Thread num: \" &lt;&lt; -(i - 8) &lt;&lt; \" \" &lt;&lt; count &lt;&lt; endl; &#125;&#125;;int main() &#123; Test test; ThreadPool pool(8); for (unsigned i = 0; i &lt; 8; ++i) &#123; pool.EnQueue(std::bind(&amp;Test::process_to_test, &amp;test, 8 - i, 1000000)); &#125; return 0;&#125; 参考 Progschj/ThreadPool：https://github.com/progschj/ThreadPool C++11线程池实现：https://blog.csdn.net/zdarks/article/details/46994607 线程池的原理及实现：https://blog.csdn.net/Hsuxu/article/details/8985931 基于c++11的100行实现简单线程池：https://blog.csdn.net/gcola007/article/details/78750220 C++11并发学习之六：线程池的实现：https://blog.csdn.net/caoshangpa/article/details/80374651 使用C++11实现线程池的两种方法：https://blog.csdn.net/liushengxi_root/article/details/83932654","tags":[{"name":"C++","slug":"C","permalink":"https://songkc.github.io/tags/C/"},{"name":"C++11","slug":"C-11","permalink":"https://songkc.github.io/tags/C-11/"},{"name":"并发编程","slug":"并发编程","permalink":"https://songkc.github.io/tags/并发编程/"}]},{"title":"C++11 - Lambda 表达式","date":"2018-12-29T09:01:42.000Z","path":"2018/12/29/C++11-Lambda表达式/","text":"C++11 的一大亮点就是引入了 Lambda 表达式。利用 Lambda 表达式，可以方便的定义和创建匿名函数。 声明 Lambda 表达式Lambda 表达式完整的声明格式如下： 1[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; 各项具体含义如下： capture list：捕获外部变量列表 params list：形参列表 mutable：用来说用是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 此外，我们还可以省略其中的某些成分来声明“不完整”的 Lambda 表达式，常见的有以下几种： 序号 格式 1 [capture list] (params list) -&gt; return type { function body } 2 [capture list] (params list) { function body } 3 [capture list] { function body } 格式 1 声明了 const 类型的表达式，这种类型的表达式不能修改捕获列表中的值。 格式 2 省略了返回值类型，但编译器可以根据以下规则推断出 Lambda 表达式的返回类型： 如果 function body 中没有 return 语句，则返回值为 void 类型； 如果 function body 中存在 return 语句，则该 Lambda 表达式的返回类型由 return 语句的返回类型确定。 格式 3 中省略了参数列表，类似普通函数中的无参函数。 捕获外部变量Lambda 表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该 Lambda 表达式使用）。那么，在哪里指定这些外部变量呢？Lambda 表达式通过在最前面的方括号 [] 来明确指明其内部可以访问的外部变量，这一过程也称作 Lambda 表达式“捕获”了外部变量。 通过一个例子来直观地说明一下： 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; f(); // 输出：123 //或通过“函数体”后面的‘()’传入参数 auto x = [](int a)&#123; cout &lt;&lt; a &lt;&lt; endl; &#125;(123); return 0;&#125; 上面这个例子先声明了一个整型变量 a，然后再创建 Lambda 表达式，该表达式“捕获”了变量 a，这样在 Lambda 表达式函数体中就可以获得该变量的值。 类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。 值捕获值捕获和参数传递中的值传递类似，被捕获的变量的值在 Lambda 表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响 Lambda 表达式中的值。示例如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; a = 321; f(); // 输出：123 return 0;&#125; 这里需要注意的是，如果以传值方式捕获外部变量，则在 Lambda 表达式函数体中不能修改该外部变量的值。 引用捕获使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符 &amp;。如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; a = 321; f(); // 输出：321 return 0;&#125; 从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。 隐式捕获上面的值捕获和引用捕获都需要我们在捕获列表中显式列出 Lambda 表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是 [=] 和 [&amp;]。[=] 表示以值捕获的方式捕获外部变量，[&amp;] 表示以引用捕获的方式捕获外部变量。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; // 隐式值捕获 a = 321; f(); // 输出：123 int b = 123; auto func = [&amp;] &#123; cout &lt;&lt; b &lt;&lt; endl; &#125;; // 隐式引用捕获 b = 321; func(); // 输出：321 return 0;&#125; 混合方式上面的例子，要么是值捕获，要么是引用捕获，Lambda 表达式还支持混合的方式捕获外部变量，混合方式主要是以上几种捕获方式的组合使用。 总结一下，C++11 中的 Lambda 表达式捕获外部变量主要有以下形式： 捕获形式 说明 [] 不捕获任何外部变量 [变量名, …] 默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符） [this] 以值的形式捕获this指针 [=] 以值的形式捕获所有外部变量 [&amp;] 以引用形式捕获所有外部变量 [=, &amp;x] 变量x以引用形式捕获，其余变量以传值形式捕获 [&amp;, x] 变量x以值的形式捕获，其余变量以引用形式捕获 修改捕获变量前面我们提到过，在 Lambda 表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用 mutable 关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [a]()mutable &#123; cout &lt;&lt; ++a; &#125;; // OK cout &lt;&lt; a &lt;&lt; endl; // 输出：123 f(); // 输出：124 return 0;&#125; Lambda 表达式的参数Lambda 表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在 Lambda 表达式中传递参数还有一些限制，主要有以下几点： 参数列表中不能有默认参数 不支持可变参数 所有参数必须有参数名","tags":[{"name":"C++","slug":"C","permalink":"https://songkc.github.io/tags/C/"},{"name":"C++11","slug":"C-11","permalink":"https://songkc.github.io/tags/C-11/"}]},{"title":"LeetCode - 671. Second Minimum Node in a Binary Tree","date":"2018-10-15T02:01:22.000Z","path":"2018/10/15/LeetCode-671-Second-Minimum-Node-In-a-Binary-Tree/","text":"DescriptionGiven a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example12345678910111213141516171819// Example 1Input: 2 / \\ 2 5 / \\ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5.// Example 2Input: 2 / \\ 2 2Output: -1Explanation: The smallest value is 2, but there isn't any second smallest value. Interface123456789101112131415/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int findSecondMinimumValue(TreeNode* root) &#123; &#125;&#125;; Solution由题意可知，父节点的值一定小于等于两个子节点的值，因而根节点的值一定是最小值，那么可以推导出值第二小的节点在根节点的左子树中或在根节点的右子树中或不存在，同时，当一个节点的值大于根节点的值(即最小值)时，由于父节点的值一定小于等于两个子节点的值，那么由该节点衍生的子树的节点的值一定大于等于该节点的值，因此该节点衍生的子树并不需要检查。 解决的方法有多种，这里我使用了 BFS（广度优先搜索）。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // unrecursion by BFS int findSecondMinimumValue(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; que.push(root); int min = root-&gt;val; int left, right, smin = INT_MAX; while (!que.empty()) &#123; TreeNode* temp = que.front(); if (min &lt; temp-&gt;val) &#123; smin = (smin &gt; temp-&gt;val ? temp-&gt;val : smin); que.pop(); continue; &#125; if (temp-&gt;left != NULL &amp;&amp; temp-&gt;right != NULL) &#123; que.push(temp-&gt;left); que.push(temp-&gt;right); &#125; que.pop(); &#125; return smin == INT_MAX ? -1 : smin; &#125;&#125;; Improvement学习了一下 LeetCode 上讨论区的做法，将递归和分治的做法也写出来。 Recursion Method（递归方法）1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // recursion int findSecondMinimumValue(TreeNode* root) &#123; if (!root) return -1; return findSecMin(root, root-&gt;val); &#125; int findSecMin(TreeNode* node, int first) &#123; if (!node) return -1; if (node-&gt;val &gt; first) return node-&gt;val; int left = findSecMin(node-&gt;left, first); int right = findSecMin(node-&gt;right, first); if (left == -1 &amp;&amp; right == -1) return -1; if (left != -1 &amp;&amp; right == -1) return left; if (right != -1 &amp;&amp; left == -1) return right; &#125;&#125;; Divide and Conquer Method （分治方法）123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // divide and conquer int findSecondMinimumValue(TreeNode* root) &#123; if (!root) return -1; if (!root-&gt;left &amp;&amp; !root-&gt;right) return -1; int left = root-&gt;left-&gt;val; int right = root-&gt;right-&gt;val; if (left == root-&gt;val) left = findSecondMinimumValue(root-&gt;left); if (right == root-&gt;val) right = findSecondMinimumValue(root-&gt;right); if (left == -1 &amp;&amp; right == -1) return -1; else if (left == -1) return right; else if (right == -1) return left; else return left &gt; right ? right : left; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://songkc.github.io/tags/二叉树/"}]},{"title":"LeetCode - 32. Longest Valid Parentheses","date":"2018-10-11T06:41:29.000Z","path":"2018/10/11/LeetCode-32-Longest-Valid-Parentheses/","text":"Description Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. Example12345For \"(()\", the longest valid parentheses substring is \"()\", which haslength = 2.Another example is \")()())\", where the longest valid parenthesessubstring is \"()()\", which has length = 4. Interface123456class Solution &#123;public: int longestValidParentheses(string s) &#123; &#125;&#125;; Solution一开始只是简单的以为是求出所有合法的圆括号的数量，就直接用一个栈去写，提交后才发现理解错了，原来题目的意思是从找出字符串中最长的合法圆括号子串的长度。 重新审题后就能发现每个合法的字串其实都是由不合法的字串分隔开的，我的思路是用一个栈存储 pair&lt;char, int&gt; 类型的元素，char 为圆括号字符，int 为此时所有合法的圆括号数量。当栈顶元素字符为 ‘(‘ 且当前字符为 ‘)’ 时，就将栈顶元素 pop 出，并将合法圆括号数量 +2，到最后栈中留下的都是不合法的圆括号，其实就相当于将合法的圆括号字串分隔开的分隔符，此时就可以利用这些分隔符求出每个合法圆括号字串的长度，取最大的字串长度即可。算法的复杂度是 $O(n^2)$。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int longestValidParentheses(string s) &#123; if (s.length() == 0) return 0; int count = 0, max = 0; stack&lt;pair&lt;char, int&gt; &gt; stk; pair&lt;char, int&gt; p(s[0], 0); stk.push(p); for (int i = 1; i &lt; s.length(); ++i) &#123; if (stk.empty()) &#123; pair&lt;char, int&gt; temp(s[i], count); stk.push(temp); continue; &#125; pair&lt;char, int&gt; top = stk.top(); if (top.first == '(' &amp;&amp; s[i] == ')') &#123; count += 2; stk.pop(); &#125; else &#123; pair&lt;char, int&gt; temp(s[i], count); stk.push(temp); continue; &#125; &#125; while (!stk.empty()) &#123; pair&lt;char, int&gt; top = stk.top(); if (top.second == count) &#123; stk.pop(); continue; &#125; int temp = count - top.second; if (max &lt; temp) max = temp; count -= temp; stk.pop(); &#125; if (max &lt; count) max = count; return max; &#125;&#125;; Improvement精简代码LeetCode 讨论区发现，许多解答思路与我的思路是一样的，但我的代码显得有些冗余了，附上精简后的代码。 12345678910111213141516class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; stk.push(-1); int maxL = 0, temp = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; temp = stk.top(); if (temp != -1 &amp;&amp; s[i] == ')' &amp;&amp; s[temp] == '(') &#123; stk.pop(); maxL = max(maxL, i - stk.top()); &#125; else stk.push(i); &#125; return maxL; &#125;&#125;; 动态规划还有用使用动态规划（DP）算法来解题的思路，这里也在此附上。 12345678910111213141516171819202122class Solution &#123;public: int longestValidParentheses(string s) &#123; int *V = new int[s.length()]; int open = 0, max = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (s[i] == '(') ++open; if (s[i] == ')' &amp;&amp; open &gt; 0) &#123; // matches found V[i] = V[i - 1] + 2; // add matches from previous if (i - V[i] &gt; 0) V[i] += V[i - V[i]]; --open; &#125; if (V[i] &gt; max) max = V[i]; &#125; delete V; return max; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://songkc.github.io/tags/字符串/"},{"name":"动态规划","slug":"动态规划","permalink":"https://songkc.github.io/tags/动态规划/"}]},{"title":"LeetCode - 551. Student Attendance Record I","date":"2018-10-05T01:02:33.000Z","path":"2018/10/05/LeetCode-551-Student-Attendence-Record-I/","text":"DescriptionYou are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present. A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record. ExampleExample 112Input: \"PPALLP\"Output: True Example 212Input: \"PPALLL\"Output: False Interface123456class Solution &#123;public: bool checkRecord(string s) &#123; &#125;&#125;; Solution先分析题目，根据题目的意思是说，只要缺勤超过两次或者迟到超过两次且是连续的就应该返回 false，缺勤超过两次这个直接记录就 OK，而这题的重点用更通俗的话来讲就是连续两天以上迟到，其实最简单的做法就是用一个变量 late 记录迟到的次数，迟到则加 1，不是迟到的则将 late 重置为 0，然后判断 late 是否大于 2 即可。这题算是比较简单的，巧妙的 if-else 就可以做出。 12345678910111213class Solution &#123;public: bool checkRecord(string s) &#123; int abs = 0, late = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (s[i] == 'A') abs++; if (s[i] == 'L') late++; else late = 0; if (abs &gt; 1 || late &gt; 2) return false; &#125; return true; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://songkc.github.io/tags/字符串/"}]},{"title":"LeetCode - 48. Rotate Image","date":"2018-09-30T11:54:52.000Z","path":"2018/09/30/LeetCode-48-Rotate-Image/","text":"Description You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. ExampleExample 112345678910111213Given input matrix =[ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Interface123456class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#125;&#125;; Solution问题主要在于不能使用额外的2维矩阵去求解，思路其实就是由内圈到外圈将整个矩阵顺时针旋转 90°，一是存放当前位置的值以便旋转后将值赋值到旋转后的新位置，二是推导出从当前位置到旋转后的新位置的公式，上述一二操作循环四个数字即可。整个算法的时间复杂度是 $O(n^2)​$。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int temp = 0, row = 0, col = 0, tmp = 0; for (int i = 0; i &lt; matrix.size() / 2; ++i) &#123; for (int j = i; j &lt; matrix.size() - i - 1; ++j) &#123; row = i; col = j; for (int k = 0; k &lt; 5; ++k) &#123; tmp = matrix[row][col]; matrix[row][col] = temp; temp = row; row = col; col = matrix.size() - 1 - temp; temp = tmp; &#125; &#125; &#125; &#125;&#125;;/* n represents the matrix's dimension row represents the row of the present position col represents the column of the present position Actually, the transform function can be written as: new_row = col new_col = n - row - 1 Example: 1 2 3 7 2 1 7 4 1 4 5 6 -&gt; 4 5 6 -&gt; 8 5 2 7 8 9 9 8 3 9 6 3*/ ImprovementLeetCode 讨论区上见到的，先将矩阵按主对角线翻转，再将翻转后的矩阵的每一行进行逆序，就可以完成对矩阵的 90° 旋转。 1234567891011121314151617181920class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = m.size(); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; i; ++j) swap(m[i][j], m[j][i]); for(int i = 0; i &lt; n; ++i) reverse(m[i].begin(), m[i].end()); &#125;&#125;;/* Example: 1 2 3 1 4 7 7 4 1 4 5 6 -&gt; 2 5 8 -&gt; 8 5 2 7 8 9 3 6 9 9 6 3*/","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://songkc.github.io/tags/数组/"}]},{"title":"LeetCode - 21. Merge Two Sorted Lists","date":"2018-09-25T05:14:51.000Z","path":"2018/09/25/LeetCode-21-Merge-Two-Sorted-Lists/","text":"Description Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; Solution合并两个已按小到大排序的链表，最简单的做法就是新建一个链表，然后比较原有的两个链表当前节点的大小，然后选择较小的节点加到新建链表上，接着将被选中的链表的节点指向他的下一个，重复以上，知道某个链表已读到末尾或两个链表都为空，然后将未读完的链表的节点直接加到新建链表上就可以。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* head = new ListNode(0); ListNode* node = head; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; node-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; node-&gt;next = l2; l2 = l2-&gt;next; &#125; node = node-&gt;next; &#125; node-&gt;next = (l1 == NULL ? l2 : l1); node = head; head = head-&gt;next; delete node; return head; &#125;&#125;; Improvement还可以通过递归实现，原理与上面相同。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* node; if (l1-&gt;val &lt; l2-&gt;val) &#123; node = l1; node-&gt;next = mergeTwoLists(l1-&gt;next, l2); &#125; else &#123; node = l1; node-&gt;next = mergeTwoLists(l1, l2-&gt;next); &#125; return node; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"LeetCode - 2. Add Two Numbers","date":"2018-09-19T02:58:21.000Z","path":"2018/09/19/LeetCode-2-Add-Two-Numbers/","text":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example12345Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; Solution题目挺简单的，就是通过链表实现大数加法，结果的每一位由三个值决定，两个是两个加数在这个数位上的值，剩下一个是上一位的进位，主要就是需要注意进位的实现，也没什么难度，可能还有需要注意的就是代码的逻辑需要简明清晰，不然很容易写的很冗长。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; int n1 = 0, n2 = 0, tmp = 0, carry = 0; ListNode *p1 = l1, *p2 = l2, *temp = NULL, *result = NULL; while (p1 != NULL || p2 != NULL || carry != 0) &#123; n1 = (p1 != NULL) ? p1-&gt;val : 0; n2 = (p2 != NULL) ? p2-&gt;val : 0; tmp = n1 + n2 + carry; carry = tmp / 10; if (result == NULL) result = new ListNode(tmp % 10); else temp-&gt;next = new ListNode(tmp % 10); p1 = (p1 == NULL) ? p1 : p1-&gt;next; p2 = (p2 == NULL) ? p2 : p2-&gt;next; if (temp == NULL) temp = result; else temp = temp-&gt;next; &#125; return result; &#125;&#125;; Improvement在 LeetCode 讨论区中发现了更简洁的代码。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"LeetCode - 1. Two Sum","date":"2018-09-12T14:20:34.000Z","path":"2018/09/12/LeetCode-1-Two-Sum/","text":"DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Interface123456class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; &#125;&#125;; Solution一开始，我想到用 stl::map 来解决，数组元素值作为 map 的键，下标则是作为对应的值。将 target 减去当前元素值，看 map 中是否存在差值的键值，如果存在就说明找到了，不存在则将当前元素值和对应下标存入 map 中，以便后面的元素能对应。 但是，我发现如果出现目标是一个元素的两倍，那么输出的结果将是两次那个元素的下标。为了解决这个情况，我调整了一下语句的顺序，将对 map 赋值的语句放到查找后，这样就不会出现上面所说的问题了。 1234567891011121314151617181920// e.gintput: [2 4 4 7 10], target = 8output: [1 1]class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; reflect; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; if (reflect.find(target - nums[i]) != reflect.end()) &#123; result.push_back(reflect[target - nums[i]]); result.push_back(reflect[nums[i]]); return result; &#125; reflect[nums[i]] = i; &#125; return result; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://songkc.github.io/tags/数组/"},{"name":"哈希表","slug":"哈希表","permalink":"https://songkc.github.io/tags/哈希表/"}]},{"title":"Hello World","date":"2018-09-01T04:00:00.000Z","path":"2018/09/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://songkc.github.io/tags/Hexo/"}]}]