[{"title":"剑指Offer-链表中环的入口结点","date":"2019-03-23T10:11:33.000Z","path":"2019/03/23/剑指Offer-链表中环的入口结点/","text":"题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 NULL。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; &#125;&#125;; 解答使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122232425/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::map ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = pHead; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021222324/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::set ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (pHead != nullptr) &#123; if (nodeset.count(pHead) &gt; 0) return pHead; nodeset.insert(pHead); pHead = pHead-&gt;next; &#125; return nullptr; &#125;&#125;; 使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via fast pointer and slow pointer ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; ListNode *slow = pHead, *fast = pHead; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = pHead; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"剑指Offer-二叉树的镜像","date":"2019-03-22T03:19:58.000Z","path":"2019/03/22/剑指Offer-二叉树的镜像/","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述1234567二叉树的镜像定义： 源二叉树 镜像二叉树 8 8 / \\ / \\ 6 10 10 6 / \\ / \\ / \\ / \\ 5 7 9 11 11 9 7 5 接口123456789101112131415/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; &#125;&#125;; 解答递归方法对于每个二叉树结点都将左右子结点交换就可以，因此递归是最简短的形式，可以先继续递归左右子结点再交换左右子结点，也可以先交换左右子结点再继续递归左右子结点。 继续递归左右子结点时，可以先检查左右子结点是否为 nullptr，如果子结点是 nullptr，则不需要进行递归，可以减少内存空间和运行时间的消耗，因为递归需要为递归函数的参数和局部变量分配内存空间，同时还需要对递归函数进行压栈操作和递归函数执行及执行完后的出栈操作，这些都需要消耗时间。 1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; if (pRoot-&gt;left != nullptr) Mirror(pRoot-&gt;left); if (pRoot-&gt;right != nullptr) Mirror(pRoot-&gt;right); TreeNode* temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; &#125;&#125;; stl::queue 非递归方法通过队列以层次遍历的方式，遍历每一个二叉树结点，取出结点将左右子结点交换，再将非 nullptr 的子结点加入队列中，直到队列为空。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; queue&lt;TreeNode*&gt; que; que.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (que.empty() == false) &#123; node = que.front(); que.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) que.push(node-&gt;left); if (node-&gt;right != nullptr) que.push(node-&gt;right); &#125; &#125;&#125;; stl::stack 非递归方法与 stl::queue 的思路相似，故不再叙述。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; stack&lt;TreeNode*&gt; stk; stk.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (stk.empty() == false) &#123; node = stk.top(); stk.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) stk.push(node-&gt;left); if (node-&gt;right != nullptr) stk.push(node-&gt;right); &#125; &#125;&#125;;","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"},{"name":"二叉树","slug":"二叉树","permalink":"https://songkc.github.io/tags/二叉树/"}]},{"title":"Hello World","date":"2019-01-21T12:28:50.308Z","path":"2019/01/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]