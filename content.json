[{"title":"剑指Offer - 删除链表中重复的结点","date":"2019-03-23T18:03:24.000Z","path":"2019/03/24/剑指Offer-删除链表中重复的结点/","text":"题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; &#125;&#125;; 解答非递归方法使用三个指针，分别是指向当前结点的前一结点的指针 prev，指向当前结点的指针 curr，指向当前结点的后一结点的指针 latter，为了让第一个节点也有前一结点，定义一个 ListNode head 变量，其 next 值指向第一个结点。 接着从 curr 为第一个结点开始遍历，直到 latter 为 nullptr。 遍历过程中如果 curr 与 latter 的值不同，则 prev, curr, latter 都往后移一个结点； 如果遇到 curr 和 latter 的值相同，就需要再进入一层循环，删除每一个与 curr 值相同的 latter，并将 latter 指向其自身的下一个，直到 latter 与 curr 的值不同或 latter 为 nullptr 则第二层循环结束，并将当前的 curr 结点也删除，然后 curr 指向当前 latter 的结点，prev-&gt;next 指向 curr，如果 latter 不为 nullptr 则 latter 指向当前 latter 的下一个结点。 1234567891011121314151617181920212223242526272829303132333435363738/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == nullptr) return pHead; ListNode head(0), *temp = nullptr; head.next = pHead; ListNode *prev = &amp;head, *curr = pHead, *latter = pHead-&gt;next; while (latter != nullptr) &#123; if (curr-&gt;val == latter-&gt;val) &#123; while (latter != nullptr &amp;&amp; curr-&gt;val == latter-&gt;val) &#123; temp = latter; latter = latter-&gt;next; delete temp; &#125; temp = curr; curr = latter; prev-&gt;next = curr; delete temp; if (latter != nullptr) latter = latter-&gt;next; &#125; else &#123; prev = curr; curr = latter; latter = latter-&gt;next; &#125; &#125; return head.next; &#125;&#125;; 递归方法递归的主要思路是：判断当前结点与下一结点的值是否相同，如果不同则当前结点为不重复的一个结点，然后就是从当前结点指向的下一个结点开始找不重复的结点；如果当前结点与下一结点的值相同，那么就需要找到第一个与当前结点不同的结点，然后从这个结点开始再找不重复的结点。 1234567891011121314151617181920212223242526272829303132333435/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; if (pHead-&gt;next == nullptr) return pHead; ListNode *node = nullptr; if (pHead-&gt;val != pHead-&gt;next-&gt;val) &#123; node = pHead; node-&gt;next = deleteDuplication(node-&gt;next); &#125; else &#123; ListNode *temp = nullptr; node = pHead-&gt;next; while (node != nullptr &amp;&amp; pHead-&gt;val == node-&gt;val) &#123; temp = node; node = node-&gt;next; delete temp; &#125; delete pHead; if (node == nullptr) return nullptr; // 从第一个与当前结点不同的结点再次开始递归 node = deleteDuplication(node); &#125; return node; &#125;&#125;;","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"LeetCode - 142. Linked List Cycle II","date":"2019-03-23T13:28:14.000Z","path":"2019/03/23/LeetCode-142-Linked-List-Cycle-II/","text":"DescriptionGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. ExampleExample 11234Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to thesecond node. Example 21234Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to thefirst node. Example 3123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; &#125;&#125;; Solution使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = head; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (head != nullptr) &#123; if (nodeset.count(head) &gt; 0) return head; nodeset.insert(head); head = head-&gt;next; &#125; return nullptr; &#125;&#125;; Improvement使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; ListNode *slow = head, *fast = head; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = head; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"剑指Offer - 链表中环的入口结点","date":"2019-03-23T10:11:33.000Z","path":"2019/03/23/剑指Offer-链表中环的入口结点/","text":"题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 NULL。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; &#125;&#125;; 解答使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122232425/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::map ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = pHead; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021222324/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::set ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (pHead != nullptr) &#123; if (nodeset.count(pHead) &gt; 0) return pHead; nodeset.insert(pHead); pHead = pHead-&gt;next; &#125; return nullptr; &#125;&#125;; 使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829303132/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via fast pointer and slow pointer ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; ListNode *slow = pHead, *fast = pHead; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = pHead; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"剑指Offer - 二叉树的镜像","date":"2019-03-22T03:19:58.000Z","path":"2019/03/22/剑指Offer-二叉树的镜像/","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述1234567二叉树的镜像定义： 源二叉树 镜像二叉树 8 8 / \\ / \\ 6 10 10 6 / \\ / \\ / \\ / \\ 5 7 9 11 11 9 7 5 接口123456789101112131415/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; &#125;&#125;; 解答递归方法对于每个二叉树结点都将左右子结点交换就可以，因此递归是最简短的形式，可以先继续递归左右子结点再交换左右子结点，也可以先交换左右子结点再继续递归左右子结点。 继续递归左右子结点时，可以先检查左右子结点是否为 nullptr，如果子结点是 nullptr，则不需要进行递归，可以减少内存空间和运行时间的消耗，因为递归需要为递归函数的参数和局部变量分配内存空间，同时还需要对递归函数进行压栈操作和递归函数执行及执行完后的出栈操作，这些都需要消耗时间。 1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; if (pRoot-&gt;left != nullptr) Mirror(pRoot-&gt;left); if (pRoot-&gt;right != nullptr) Mirror(pRoot-&gt;right); TreeNode* temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; &#125;&#125;; stl::queue 非递归方法通过队列以层次遍历的方式，遍历每一个二叉树结点，取出结点将左右子结点交换，再将非 nullptr 的子结点加入队列中，直到队列为空。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; queue&lt;TreeNode*&gt; que; que.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (que.empty() == false) &#123; node = que.front(); que.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) que.push(node-&gt;left); if (node-&gt;right != nullptr) que.push(node-&gt;right); &#125; &#125;&#125;; stl::stack 非递归方法与 stl::queue 的思路相似，故不再叙述。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; stack&lt;TreeNode*&gt; stk; stk.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (stk.empty() == false) &#123; node = stk.top(); stk.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) stk.push(node-&gt;left); if (node-&gt;right != nullptr) stk.push(node-&gt;right); &#125; &#125;&#125;;","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"},{"name":"二叉树","slug":"二叉树","permalink":"https://songkc.github.io/tags/二叉树/"}]},{"title":"LeetCode - 32. Longest Valid Parentheses","date":"2018-10-11T06:41:29.000Z","path":"2018/10/11/LeetCode-32-Longest-Valid-Parentheses/","text":"Description Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. Example12345For \"(()\", the longest valid parentheses substring is \"()\", which haslength = 2.Another example is \")()())\", where the longest valid parenthesessubstring is \"()()\", which has length = 4. Interface123456class Solution &#123;public: int longestValidParentheses(string s) &#123; &#125;&#125;; Solution一开始只是简单的以为是求出所有合法的圆括号的数量，就直接用一个栈去写，提交后才发现理解错了，原来题目的意思是从找出字符串中最长的合法圆括号子串的长度。 重新审题后就能发现每个合法的字串其实都是由不合法的字串分隔开的，我的思路是用一个栈存储 pair&lt;char, int&gt; 类型的元素，char 为圆括号字符，int 为此时所有合法的圆括号数量。当栈顶元素字符为 ‘(‘ 且当前字符为 ‘)’ 时，就将栈顶元素 pop 出，并将合法圆括号数量 +2，到最后栈中留下的都是不合法的圆括号，其实就相当于将合法的圆括号字串分隔开的分隔符，此时就可以利用这些分隔符求出每个合法圆括号字串的长度，取最大的字串长度即可。算法的复杂度是 $O(n^2)$。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int longestValidParentheses(string s) &#123; if (s.length() == 0) return 0; int count = 0, max = 0; stack&lt;pair&lt;char, int&gt; &gt; stk; pair&lt;char, int&gt; p(s[0], 0); stk.push(p); for (int i = 1; i &lt; s.length(); ++i) &#123; if (stk.empty()) &#123; pair&lt;char, int&gt; temp(s[i], count); stk.push(temp); continue; &#125; pair&lt;char, int&gt; top = stk.top(); if (top.first == '(' &amp;&amp; s[i] == ')') &#123; count += 2; stk.pop(); &#125; else &#123; pair&lt;char, int&gt; temp(s[i], count); stk.push(temp); continue; &#125; &#125; while (!stk.empty()) &#123; pair&lt;char, int&gt; top = stk.top(); if (top.second == count) &#123; stk.pop(); continue; &#125; int temp = count - top.second; if (max &lt; temp) max = temp; count -= temp; stk.pop(); &#125; if (max &lt; count) max = count; return max; &#125;&#125;; Improvement精简代码LeetCode 讨论区发现，许多解答思路与我的思路是一样的，但我的代码显得有些冗余了，附上精简后的代码。 12345678910111213141516class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; stk.push(-1); int maxL = 0, temp = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; temp = stk.top(); if (temp != -1 &amp;&amp; s[i] == ')' &amp;&amp; s[temp] == '(') &#123; stk.pop(); maxL = max(maxL, i - stk.top()); &#125; else stk.push(i); &#125; return maxL; &#125;&#125;; 动态规划还有用使用动态规划（DP）算法来解题的思路，这里也在此附上。 123456789101112131415161718192021class Solution &#123;public: int longestValidParentheses(string s) &#123; int *V = new int[s.length()]; int open = 0, max = 0; for (int i = 0; i &lt; s.length(); ppi) &#123; if (s[i] == '(') open++; if (s[i] == ')' &amp;&amp; open &gt; 0) &#123; // matches found V[i] = 2+ V[i-1]; // add matches from previous if(i - V[i] &gt; 0) V[i] += V[i - V[i]]; open--; &#125; if (V[i] &gt; max) max = V[i]; &#125; return max; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://songkc.github.io/tags/字符串/"},{"name":"动态规划","slug":"动态规划","permalink":"https://songkc.github.io/tags/动态规划/"}]},{"title":"LeetCode - 551. Student Attendance Record I","date":"2018-10-05T01:02:33.000Z","path":"2018/10/05/LeetCode-551-Student-Attendence-Record-I/","text":"DescriptionYou are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present. A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record. ExampleExample 112Input: \"PPALLP\"Output: True Example 212Input: \"PPALLL\"Output: False Interface123456class Solution &#123;public: bool checkRecord(string s) &#123; &#125;&#125;; Solution先分析题目，根据题目的意思是说，只要缺勤超过两次或者迟到超过两次且是连续的就应该返回 false，缺勤超过两次这个直接记录就 OK，而这题的重点用更通俗的话来讲就是连续两天以上迟到，其实最简单的做法就是用一个变量 late 记录迟到的次数，迟到则加 1，不是迟到的则将 late 重置为 0，然后判断 late 是否大于 2 即可。这题算是比较简单的，巧妙的 if-else 就可以做出。 12345678910111213class Solution &#123;public: bool checkRecord(string s) &#123; int abs = 0, late = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (s[i] == 'A') abs++; if (s[i] == 'L') late++; else late = 0; if (abs &gt; 1 || late &gt; 2) return false; &#125; return true; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://songkc.github.io/tags/字符串/"}]},{"title":"LeetCode - 48. Rotate Image","date":"2018-09-30T11:54:52.000Z","path":"2018/09/30/LeetCode-48-Rotate-Image/","text":"Description You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. ExampleExample 112345678910111213Given input matrix =[ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Interface123456class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#125;&#125;; Solution问题主要在于不能使用额外的2维矩阵去求解，思路其实就是由内圈到外圈将整个矩阵顺时针旋转 90°，一是存放当前位置的值以便旋转后将值赋值到旋转后的新位置，二是推导出从当前位置到旋转后的新位置的公式，上述一二操作循环四个数字即可。整个算法的时间复杂度是 $O(n^2)​$。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int temp = 0, row = 0, col = 0, tmp = 0; for (int i = 0; i &lt; matrix.size() / 2; ++i) &#123; for (int j = i; j &lt; matrix.size() - i - 1; ++j) &#123; row = i; col = j; for (int k = 0; k &lt; 5; ++k) &#123; tmp = matrix[row][col]; matrix[row][col] = temp; temp = row; row = col; col = matrix.size() - 1 - temp; temp = tmp; &#125; &#125; &#125; &#125;&#125;;/* n represents the matrix's dimension row represents the row of the present position col represents the column of the present position Actually, the transform function can be written as: new_row = col new_col = n - row - 1 Example: 1 2 3 7 2 1 7 4 1 4 5 6 -&gt; 4 5 6 -&gt; 8 5 2 7 8 9 9 8 3 9 6 3*/ ImprovementLeetCode 讨论区上见到的，先将矩阵按主对角线翻转，再将翻转后的矩阵的每一行进行逆序，就可以完成对矩阵的 90° 旋转。 1234567891011121314151617181920class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = m.size(); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; i; ++j) swap(m[i][j], m[j][i]); for(int i = 0; i &lt; n; ++i) reverse(m[i].begin(), m[i].end()); &#125;&#125;;/* Example: 1 2 3 1 4 7 7 4 1 4 5 6 -&gt; 2 5 8 -&gt; 8 5 2 7 8 9 3 6 9 9 6 3*/","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://songkc.github.io/tags/数组/"}]},{"title":"LeetCode - 21. Merge Two Sorted Lists","date":"2018-09-25T05:14:51.000Z","path":"2018/09/25/LeetCode-21-Merge-Two-Sorted-Lists/","text":"Description Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; Solution合并两个已按小到大排序的链表，最简单的做法就是新建一个链表，然后比较原有的两个链表当前节点的大小，然后选择较小的节点加到新建链表上，接着将被选中的链表的节点指向他的下一个，重复以上，知道某个链表已读到末尾或两个链表都为空，然后将未读完的链表的节点直接加到新建链表上就可以。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* head = new ListNode(0); ListNode* node = head; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; node-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; node-&gt;next = l2; l2 = l2-&gt;next; &#125; node = node-&gt;next; &#125; node-&gt;next = (l1 == NULL ? l2 : l1); node = head; head = head-&gt;next; delete node; return head; &#125;&#125;; Improvement还可以通过递归实现，原理与上面相同。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* node; if (l1-&gt;val &lt; l2-&gt;val) &#123; node = l1; node-&gt;next = mergeTwoLists(l1-&gt;next, l2); &#125; else &#123; node = l1; node-&gt;next = mergeTwoLists(l1, l2-&gt;next); &#125; return node; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"LeetCode - 2. Add Two Numbers","date":"2018-09-19T02:58:21.000Z","path":"2018/09/19/LeetCode-2-Add-Two-Numbers/","text":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example12345Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; Solution题目挺简单的，就是通过链表实现大数加法，结果的每一位由三个值决定，两个是两个加数在这个数位上的值，剩下一个是上一位的进位，主要就是需要注意进位的实现，也没什么难度，可能还有需要注意的就是代码的逻辑需要简明清晰，不然很容易写的很冗长。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; int n1 = 0, n2 = 0, tmp = 0, carry = 0; ListNode *p1 = l1, *p2 = l2, *temp = NULL, *result = NULL; while (p1 != NULL || p2 != NULL || carry != 0) &#123; n1 = (p1 != NULL) ? p1-&gt;val : 0; n2 = (p2 != NULL) ? p2-&gt;val : 0; tmp = n1 + n2 + carry; carry = tmp / 10; if (result == NULL) result = new ListNode(tmp % 10); else temp-&gt;next = new ListNode(tmp % 10); p1 = (p1 == NULL) ? p1 : p1-&gt;next; p2 = (p2 == NULL) ? p2 : p2-&gt;next; if (temp == NULL) temp = result; else temp = temp-&gt;next; &#125; return result; &#125;&#125;; Improvement在 LeetCode 讨论区中发现了更简洁的代码。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"LeetCode - 1. Two Sum","date":"2018-09-12T14:20:34.000Z","path":"2018/09/12/LeetCode-1-Two-Sum/","text":"DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Interface123456class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; &#125;&#125;; Solution一开始，我想到用 stl::map 来解决，数组元素值作为 map 的键，下标则是作为对应的值。将 target 减去当前元素值，看 map 中是否存在差值的键值，如果存在就说明找到了，不存在则将当前元素值和对应下标存入 map 中，以便后面的元素能对应。 但是，我发现如果出现目标是一个元素的两倍，那么输出的结果将是两次那个元素的下标。为了解决这个情况，我调整了一下语句的顺序，将对 map 赋值的语句放到查找后，这样就不会出现上面所说的问题了。 1234567891011121314151617181920// e.gintput: [2 4 4 7 10], target = 8output: [1 1]class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; reflect; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; if (reflect.find(target - nums[i]) != reflect.end()) &#123; result.push_back(reflect[target - nums[i]]); result.push_back(reflect[nums[i]]); return result; &#125; reflect[nums[i]] = i; &#125; return result; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://songkc.github.io/tags/数组/"},{"name":"哈希表","slug":"哈希表","permalink":"https://songkc.github.io/tags/哈希表/"}]},{"title":"Hello World","date":"2018-09-01T04:00:00.000Z","path":"2018/09/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://songkc.github.io/tags/Hexo/"}]}]