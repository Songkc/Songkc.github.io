[{"title":"剑指Offer - 从尾到头打印链表","date":"2019-04-16T16:42:17.000Z","path":"2019/04/17/剑指Offer-从尾到头打印链表/","text":"题目描述输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList。 接口123456789101112131415/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; &#125;&#125;; 解答使用 std::stack栈是先进后出的一种数据结构，很符合本题要求从尾到头逆序输出，因此可以使用 std::stack 先将链表所有的值从头节点到尾节点的顺序压入栈中，然后将栈顶元素推入 vector 中再将栈顶元素出栈，重复操作直到栈为空。 1234567891011121314151617181920212223242526/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; array; if (head == nullptr) return array; stack&lt;int&gt; stk; while (head != nullptr) &#123; stk.push(head-&gt;val); head = head-&gt;next; &#125; while (stk.empty() != false) &#123; array.push_back(stk.top()); stk.pop(); &#125; return array; &#125;&#125;; 逆序链表在这一题中，可以先将链表逆序，再将逆序的链表的值推入 vector 中。对已经构建好的链表而言，逆序链表的关键在于从原链表第二个节点开始将每一个节点的 next 指针指向其原链表中的前一节点，原本的头节点的 next 指针指向 nullptr。 123456789101112131415161718192021222324252627282930/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; array; if (head == nullptr) return array; if (head-&gt;next == nullptr) return vector&lt;int&gt;(1, head-&gt;val); ListNode *latter = head-&gt;next, *temp = nullptr; head-&gt;next = nullptr; while (latter != nullptr) &#123; temp = latter-&gt;next; latter-&gt;next = head; head = latter; latter = temp; &#125; while (head != nullptr) &#123; array.push_back(head-&gt;val); head = head-&gt;next; &#125; return array; &#125;&#125;; 递归方法递归的思路是：假如当前节点指向的下一节点不为空，则先将下一节点加入 vector 中，再将当前节点加入 vector 中。故而会一直递归到尾节点，第一个加入 vector 的将是尾节点，再一层层往上从而达到逆序将链表节点的值加入到 vector 中。 这里要注意的点是递归函数处，vector 必须使用引用传递，否则通过值传递得到的 vector 结果将是空的 vector。 12345678910111213141516171819202122232425/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; array; if (head == nullptr) return array; recursePushBack(array, head); return array; &#125; void recursePushBack(vector&lt;int&gt; &amp;array, ListNode *node) &#123; if (node-&gt;next != nullptr) recursePushBack(array, node-&gt;next); array.push_back(node-&gt;val); return; &#125;&#125;;","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"剑指Offer - 删除链表中重复的结点","date":"2019-03-23T18:03:24.000Z","path":"2019/03/24/剑指Offer-删除链表中重复的结点/","text":"题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; &#125;&#125;; 解答非递归方法使用三个指针，分别是指向当前结点的前一结点的指针 prev，指向当前结点的指针 curr，指向当前结点的后一结点的指针 latter，为了让第一个节点也有前一结点，定义一个 ListNode head 变量，其 next 值指向第一个结点。 接着从 curr 为第一个结点开始遍历，直到 latter 为 nullptr。 遍历过程中如果 curr 与 latter 的值不同，则 prev, curr, latter 都往后移一个结点； 如果遇到 curr 和 latter 的值相同，就需要再进入一层循环，删除每一个与 curr 值相同的 latter，并将 latter 指向其自身的下一个，直到 latter 与 curr 的值不同或 latter 为 nullptr 则第二层循环结束，并将当前的 curr 结点也删除，然后 curr 指向当前 latter 的结点，prev-&gt;next 指向 curr，如果 latter 不为 nullptr 则 latter 指向当前 latter 的下一个结点。 1234567891011121314151617181920212223242526272829303132333435363738/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == nullptr) return pHead; ListNode head(0), *temp = nullptr; head.next = pHead; ListNode *prev = &amp;head, *curr = pHead, *latter = pHead-&gt;next; while (latter != nullptr) &#123; if (curr-&gt;val == latter-&gt;val) &#123; while (latter != nullptr &amp;&amp; curr-&gt;val == latter-&gt;val) &#123; temp = latter; latter = latter-&gt;next; delete temp; &#125; temp = curr; curr = latter; prev-&gt;next = curr; delete temp; if (latter != nullptr) latter = latter-&gt;next; &#125; else &#123; prev = curr; curr = latter; latter = latter-&gt;next; &#125; &#125; return head.next; &#125;&#125;; 递归方法递归的主要思路是：判断当前结点与下一结点的值是否相同，如果不同则当前结点为不重复的一个结点，然后就是从当前结点指向的下一个结点开始找不重复的结点；如果当前结点与下一结点的值相同，那么就需要找到第一个与当前结点不同的结点，然后从这个结点开始再找不重复的结点。 1234567891011121314151617181920212223242526272829303132333435/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; if (pHead-&gt;next == nullptr) return pHead; ListNode *node = nullptr; if (pHead-&gt;val != pHead-&gt;next-&gt;val) &#123; node = pHead; node-&gt;next = deleteDuplication(node-&gt;next); &#125; else &#123; ListNode *temp = nullptr; node = pHead-&gt;next; while (node != nullptr &amp;&amp; pHead-&gt;val == node-&gt;val) &#123; temp = node; node = node-&gt;next; delete temp; &#125; delete pHead; if (node == nullptr) return nullptr; // 从第一个与当前结点不同的结点再次开始递归 node = deleteDuplication(node); &#125; return node; &#125;&#125;;","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"LeetCode - 142. Linked List Cycle II","date":"2019-03-23T13:28:14.000Z","path":"2019/03/23/LeetCode-142-Linked-List-Cycle-II/","text":"DescriptionGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. ExampleExample 11234Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to thesecond node. Example 21234Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to thefirst node. Example 3123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; &#125;&#125;; Solution使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = head; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (head != nullptr) &#123; if (nodeset.count(head) &gt; 0) return head; nodeset.insert(head); head = head-&gt;next; &#125; return nullptr; &#125;&#125;; Improvement使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; ListNode *slow = head, *fast = head; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = head; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"剑指Offer - 链表中环的入口结点","date":"2019-03-23T10:11:33.000Z","path":"2019/03/23/剑指Offer-链表中环的入口结点/","text":"题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 NULL。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; &#125;&#125;; 解答使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122232425/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::map ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = pHead; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021222324/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::set ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (pHead != nullptr) &#123; if (nodeset.count(pHead) &gt; 0) return pHead; nodeset.insert(pHead); pHead = pHead-&gt;next; &#125; return nullptr; &#125;&#125;; 使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829303132/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via fast pointer and slow pointer ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; ListNode *slow = pHead, *fast = pHead; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = pHead; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"剑指Offer - 二叉树的镜像","date":"2019-03-22T03:19:58.000Z","path":"2019/03/22/剑指Offer-二叉树的镜像/","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述1234567二叉树的镜像定义： 源二叉树 镜像二叉树 8 8 / \\ / \\ 6 10 10 6 / \\ / \\ / \\ / \\ 5 7 9 11 11 9 7 5 接口123456789101112131415/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; &#125;&#125;; 解答递归方法对于每个二叉树结点都将左右子结点交换就可以，因此递归是最简短的形式，可以先继续递归左右子结点再交换左右子结点，也可以先交换左右子结点再继续递归左右子结点。 继续递归左右子结点时，可以先检查左右子结点是否为 nullptr，如果子结点是 nullptr，则不需要进行递归，可以减少内存空间和运行时间的消耗，因为递归需要为递归函数的参数和局部变量分配内存空间，同时还需要对递归函数进行压栈操作和递归函数执行及执行完后的出栈操作，这些都需要消耗时间。 1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; if (pRoot-&gt;left != nullptr) Mirror(pRoot-&gt;left); if (pRoot-&gt;right != nullptr) Mirror(pRoot-&gt;right); TreeNode* temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; &#125;&#125;; stl::queue 非递归方法通过队列以层次遍历的方式，遍历每一个二叉树结点，取出结点将左右子结点交换，再将非 nullptr 的子结点加入队列中，直到队列为空。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; queue&lt;TreeNode*&gt; que; que.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (que.empty() == false) &#123; node = que.front(); que.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) que.push(node-&gt;left); if (node-&gt;right != nullptr) que.push(node-&gt;right); &#125; &#125;&#125;; stl::stack 非递归方法与 stl::queue 的思路相似，故不再叙述。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; stack&lt;TreeNode*&gt; stk; stk.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (stk.empty() == false) &#123; node = stk.top(); stk.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) stk.push(node-&gt;left); if (node-&gt;right != nullptr) stk.push(node-&gt;right); &#125; &#125;&#125;;","tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://songkc.github.io/tags/二叉树/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"I/O 多路复用：select、poll 和 epoll","date":"2019-03-01T17:03:44.000Z","path":"2019/03/02/I-O多路复用：select、poll和epoll/","text":"I/O 多路复用I/O 多路复用实际上就是用 select, poll, epoll 监听多个 I/O 对象，当 I/O 对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个 Socket。I/O 多路复用的流程： 当用户进程调用了 select，那么整个进程会被阻塞，而同时，内核会“监视” select 负责的文件描述符集合，当集合中任何一个的数据准备好了，select 就会返回。这个时候用户进程再调用 read 操作，将数据从内核空间拷贝到用户进程。 所以，I/O 多路复用的特点是通过一种机制使得一个进程或一个线程能同时等待多个文件描述符的 I/O 操作，而这些文件描述符其中的任意一个进入读就绪状态，select() 函数就可以返回。这样，多个描述符的 I/O 操作都能在一个进程或线程内并发交替地顺序完成，这就叫 I/O 多路复用，这里的“复用”指的是复用同一个进程或线程。 select、poll 和 epoll 概述select，poll，epoll 都是 I/O 多路复用的机制。I/O 多路复用就是通过一种机制，可以监视多个描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，也就是说它们的职责不是进行 I/O 操作，而是帮助调用者寻找当前就绪的设备。但 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。 selectselect 介绍select 函数在一段指定时间内，监听用户感兴趣的一组支持非阻塞的 I/O 文件描述符上的可读、可写和异常事件，直至某一个文件描述符触发了事件或者超过了指定的等待时间。select 能够监视的文件描述符的数量存在最大限制，通常是 1024。 select 接口函数原型如下： 1234#include &lt;sys/select.h&gt;// 返回值：正常工作返回就绪描述符的数目，超时返回0，出错返回-1int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout) 函数参数介绍如下： 第一个参数 maxfdp1 指定待测试的文件描述符个数，它的值是待测试的最大文件描述符加 1（因此把该参数命名为 maxfdp1），文件描述字 0、1、2 … maxfdp1-2、maxfdp1-1 均将被测试（因为文件描述符是从0开始的）。 中间的三个参数 readset、writeset 和 exceptset 是指定我们要让内核测试读、写和异常条件的文件描述符的集合。如果并不需要监听某一个，就可以把它设为空指针。 struct fd_set 结构体是文件描述符集，该结构体实际上是一个整型数组，数组中的每个元素的每一位标记一个文件描述符。fd_set 能容纳的文件描述符数量由 FD_SETSIZE 指定，一般情况下，FD_SETSIZ E等于1024，这就限制了 select 能同时处理的文件描述符的总量。struct fd_set 可通过以下四个函数进行操作： void FD_ZERO(fd_set *fdset); // 清空集合 void FD_SET(int fd, fd_set *fdset); // 将一个给定的文件描述符加入集合之中 void FD_CLR(int fd, fd_set *fdset); // 将一个给定的文件描述符从集合中删除 int FD_ISSET(int fd, fd_set *fdset); // 检查集合中指定的文件描述符是否可以读写 timeout 则是告知内核等待所指定描述字中的任何一个就绪可花多少时间。struct timeval 结构用于指定这段时间的秒数和微秒数。 1234struct timeval &#123; long tv_sec; //seconds long tv_usec; //microseconds&#125;; 这个参数有三种可能： 永远等待下去：仅在有一个文件描述符准备好 I/O 时才返回。只要将该参数设置为空指针 NULL。 等待一段固定时间：在有一个描述字准备好 I/O 时返回，但是不超过由该参数所指向的 struct timeval 结构中指定的秒数和微秒数。 根本不等待：检查文件描述符后立即返回，这称为轮询。为此，该参数必须指向一个 struct timeval 结构，而且其中的定时器值必须为 0。 select 总结select 创建了 3 个文件描述符集合（fd_set）并拷贝到内核中，分别监听读、写、异常事件。select 可以监听的文件描述符数量受到单个进程所能打开的文件描述符的限制，默认为 1024，采用轮询方式遍历所有的文件描述符，最后返回一个文件描述符是否就绪的 mask 掩码，并根据 mask 掩码给 fd_set 赋值。将之前的 fd_set 拷贝传出到用户态并返回就绪的文件描述符的总个数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。应用程序索引就绪文件描述符的时间复杂度是 O(n)。再次调用 select 时，需要将新的 fd_set 监听文件描述符集合再次拷贝传入内核同时 select 只能工作在效率相对较低的 LT 模式下。 pollpoll 介绍poll 的机制与 select 类似，与 select 在本质上没有太大差别，同时管理多个文件描述符也是进行轮询，根据描述符的状态进行处理，但是 poll 相比 select 没有最大文件描述符数量的限制。但 poll 和 select 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 poll 接口函数格式如下所示： 1234# include &lt;poll.h&gt;// 返回值：正常工作返回就绪描述符的数目，超时返回0，出错返回-1int poll(struct pollfd *fds, unsigned int nfds, int timeout); 函数参数介绍如下： 第一个参数 fds 是指向一个结构体数组的第一个元素的指针，每个元素都是一个 struct pollfd 结构，用于指定测试某个给定描述符的条件。 每一个 struct pollfd 结构体指定一个被监视的文件描述符，每个结构体的 events 域是监视该文件描述符的事件类型，由用户来设置这个域。revents 域是文件描述符的操作结果事件类型，内核在调用返回时设置这个域。events 域中请求的任何事件类型都可能在 revents 域中返回。 12345struct pollfd &#123; int fd; /* 文件描述符 */ short events; /* 等待的事件 */ short revents; /* 实际发生了的事件 */&#125;; poll 的事件类型： 第二个参数 nfds 是要监听的文件描述符的个数，也就是数组 fds 的元素个数。 第三个参数 timeout 意义与 select 相同。timeout 参数指定等待的毫秒数，无论 I/O 是否准备好，poll 都会返回。timeout 指定为负数值表示无限等待，使 poll 一直挂起直到一个指定事件发生；timeout 为 0 指示 poll 调用立即返回并列出准备好 I/O 的文件描述符，但并不等待其它的事件。这种情况下，poll 就像它的名字那样，一旦选举出来，立即返回。 poll 总结使用 poll 和 select 不一样，你不需要显式地请求异常情况报告。POLLIN | POLLPRI 等价于 select 的读事件，POLLOUT |POLLWRBAND 等价于 select 的写事件。POLLIN 等价于 POLLRDNORM |POLLRDBAND，而POLLOUT 则等价于 POLLWRNORM。例如，要同时监视一个文件描述符是否可读和可写，我们可以设置 events 为 POLLIN |POLLOUT。在 poll 返回时，我们可以检查 revents 中的标志，对应于文件描述符请求的 events 结构体。如果 POLLIN 事件被设置，则文件描述符可以被读取而不阻塞。如果 POLLOUT 被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。 poll 将 struct pollfd 结构体数组拷贝到内核中进行监听。poll 采用链表 poll_list 来进行文件描述符的存储，因此poll 可以监听的文件描述符数量为系统可以打开的最大文件描述符数（65535）。与 select 一样采用轮询方式，查询每个文件描述符上的事件状态，如果就绪，内核就修改文件描述符对应的 revents 的值，而 events 成员保持不变，因此下次调用 poll 时，应用程序无需重置 pollfd 类型的事件集参数。将之前传入的 struct pollfd 结构体数组拷贝传出到用户态，并返回就绪文件描述符的总个数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判读。应用程序索引就绪文件描述符的时间复杂度是 O(n)。同样，poll 也只能工作在效率相对较低的 LT 模式下。 epollepoll 介绍epoll 是在 Linux 2.6 内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 来说，epoll 在使用和实现上区别很大。首先，epoll 使用一组函数来完成，而不是单独的一个函数；其次，epoll 把用户关心的文件描述符上的事件放在内核里的一个事件表中，无须像 select 和 poll 那样每次调用都要重复传入文件描述符集合事件集，这样在用户空间和内核空间的复制只需一次。 epoll 接口epoll 操作过程需要三个接口，分别如下： 12345678910#include &lt;sys/epoll.h&gt;// 调用成功返回一个文件描述符，失败返回-1并设置errno。int epoll_create(int size);// 调用成功返回0，调用失败返回-1并设置errno。int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);// 函数调用成功返回就绪文件描述符个数，失败返回-1并设置errno。int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 三个函数介绍如下： int epoll_create(int size)：创建一个 epoll 的文件描述符，size 用来告诉内核需要监听的数目一共有多少。这个参数不同于 select 中的第一个参数，给出最大监听的 fd+1 的值。需要注意的是，当创建好 epoll 文件描述符后，它就是会占用一个 fd 值，在 Linux 下如果查看 /proc/进程id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 close() 关闭，否则可能导致文件描述符被耗尽。 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)：epoll 的事件注册函数，在使用epoll_ctl 时，是把 fd 添加、修改到内核事件表中，或从内核事件表中删除 fd 的事件。它与 select 不同是在并非监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create() 的返回值，第二个参数表示需要进行的动作，用三个宏来表示： EPOLL_CTL_ADD：往事件表中注册新的 fd 事件到 epfd 中； EPOLL_CTL_MOD：修改已经注册的 fd 上的监听事件； EPOLL_CTL_DEL：从 epfd 中删除一个 fd 注册的事件； 第三个参数是需要监听的 fd，第四个参数是告诉内核需要监听什么事件类型，struct epoll_event 结构如下： 1234567891011121314// 感兴趣的事件和被触发的事件struct epoll_event &#123; __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;;// 保存触发事件的某个文件描述符相关的数据（与具体使用方式有关）typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data; events 可以是以下几个宏的集合： EPOLLIN ：表示对应的文件描述符可以读； EPOLLOUT：表示对应的文件描述符可以写； EPOLLPRI：表示对应的文件描述符有紧急的数据可读； EPOLLERR：表示对应的文件描述符发生错误； EPOLLHUP：表示对应的文件描述符被挂断； EPOLLET： 将 epoll 设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的； EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个文件描述符的话，需要再次把这个文件描述符加入到 epoll 队列里。 int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)：在一段时间内等待一组文件描述符上的事件发生，类似于 select 调用。参数 events 是一个传出型参数，epoll_wait 函数如果检测到事件就绪，就将所有就绪的事件从内核事件表（epfd 所指的文件）中复制到 events 指定的数组中，这个数组用来输出 epoll_wait 检测到的就绪事件，而不像 select 与 poll 那样，这也是 epoll 与前者最大的区别。maxevents 告诉内核这个需要监听的事件表 events 有多大，这个 maxevents 的值不能大于创建 epoll_create() 时的 size，参数 timeout 是超时时间（单位毫秒，0 会立即返回，-1 时调用将永远阻塞，直到某个事件发生）。该函数返回需要处理的事件数目，如返回 0 表示已超时。 LT 和 ET 模式epoll 对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下： LT 模式：当 epoll_wait 检测到文件描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。 ET 模式：当 epoll_wait 检测到文件描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。 LT（level triggered）是缺省的工作方式，并且同时支持阻塞和非阻塞。在这种做法中，内核通知进程一个文件描述符是否就绪了，然后进程可以对这个就绪的文件描述符进行 I/O 操作。如果不作任何操作，下一次内核还是会继续通知你的。 ET（edge triggered）是高速工作方式，只支持非阻塞。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 通知进程。然后它会假设进程知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到进程进行了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个文件描述符进行 I/O 操作从而导致它再次变成未就绪，内核是不会发送更多的通知（only once）。 ET 模式在很大程度上减少了使用 epoll 时文件描述符事件被重复触发的次数，因此效率要比 LT 模式高。在网络编程中，epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件描述符的阻塞读或阻塞写操作把处理多个文件描述符的任务饿死。 epoll 总结epoll 执行 epoll_create() 函数时会在内核创建一颗红黑树 rb_node 以及就绪链表 rdllist (存放已经就绪的文件描述符)，可以监听的文件描述符数量可以达到系统可以打开的最大文件描述符数（65535）。接着用户执行的epoll_ctl() 函数将 epoll_event 结构体拷贝传入内核，内核会在红黑树上添加相应的结点，并注册回调函数 ep_poll_callback()，内核在检测到某文件描述符可读或可写时就调用回调函数 callback，该回调函数将文件描述符放入就绪链表 rdllist 中。epoll_wait() 函数只需要观察 rdllist 中有无就绪的文件描述符即可，内核将就绪的文件描述符事件复制到传入的 epoll_event 结构体数组中返回给用户空间，所以用户只用直接遍历数组依次处理即可，即应用程序索引就绪文件描述符的时间复杂度是 O(1)。这里返回的文件描述符是通过内存映射（mmap）技术让内核和用户空间共享同一块内存传递的，减少了不必要的拷贝。再次调用 epoll 系统调用，不用重建红黑树，直接沿用已经存在的即可。epoll 支持ET模式，当内核将该事件通知给用户后，用户必须立即处理，这样就减少了可读、可写和异常事件被触发的次数。 详细的关于 select、poll 和 epoll 的比较会在下次分析。 参考 IO多路复用之select总结：https://www.cnblogs.com/Anker/p/3258674.html IO多路复用之poll总结：https://www.cnblogs.com/Anker/p/3261006.html IO多路复用之epoll总结：https://www.cnblogs.com/Anker/p/3263780.html Linux IO模式及 select、poll、epoll详解：https://segmentfault.com/a/1190000003063859 为什么epoll比select和poll更高效：https://blog.csdn.net/qq_36953135/article/details/77823893","tags":[{"name":"I/O","slug":"I-O","permalink":"https://songkc.github.io/tags/I-O/"}]},{"title":"C++11 - 线程池","date":"2019-02-26T17:47:39.000Z","path":"2019/02/27/C++11-线程池/","text":"什么是线程池？传统多线程方案中采用的服务器模型是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。 线程池则是一种采用预创建技术的多线程处理形式，在程序启动之初就创建一定数量线程，运行过程中将任务添加到队列，然后再将任务分配给已创建好的线程中自动启动这些任务。因为程序边运行边创建线程是比较耗时的，所以我们通过池化的思想，减少创建线程和销毁线程对程序资源的消耗。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。 线程池原理线程池采用预创建的技术，在程序启动之后，将立即创建一定数量的线程（N1），放入空闲队列中。这些线程都是处于阻塞状态，不消耗 CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中执行。当 N1 个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。 使用线程完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。 线程池技术正是关注如何缩短或调整 T1，T3 时间的技术，从而提高服务器程序性能的。它把 T1，T3 分别安排在程序的启动和结束的时间段或者一些空闲的时间段，这样在程序处理多个任务时，就不会有 T1，T3 的开销了。同时，线程池不仅调整 T1 和 T3 产生的时间段，而且它还显著减少了创建线程的数目。 线程池适合场景事实上，线程池并不是万能的。它有其特定的使用场合。线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。 总之线程池通常适合下面的几个场合： 单位时间内处理任务频繁而且任务处理时间短。 对实时性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。 线程池的组成部分 线程池管理器（ThreadPoolManager）：用于创建并管理线程 工作线程（WorkThread）：线程池中的线程 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行 任务队列（TaskQueue）：用于存放没有处理的任务 线程池实现原理线程池管理一个任务队列，一个线程队列，然后每次取一个任务分配给一个线程去做，循环往复。而线程池一般要复用线程，所以如果是取一个 task 分配给某一个 thread，执行完之后再重新分配，在语言层面上基本都是不支持的：一般语言的 thread 都是执行一个固定的 task 函数，执行完毕线程也就结束了，因此要如何实现 task 和 thread 的分配呢？ 思路就是：让每一个 thread 都去执行调度函数：循环获取一个 task，然后执行之。保证了 thread 函数的唯一性，而且复用线程执行 task。 线程池实现线程池代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#ifndef THREADPOOL_H_#define THREADPOOL_H_#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;functional&gt;class ThreadPool &#123; public: // constructor ThreadPool(size_t threadnum = 1); // deconstructor ~ThreadPool(); // add task bool EnQueue(std::function&lt;void()&gt;); private: // the work threads std::vector&lt;std::thread&gt; workers_; // the task queue std::queue&lt;std::function&lt;void()&gt;&gt; tasks_; // the task queue lock std::mutex mutex_; // condition variable std::condition_variable condition_; // constrol thread pool bool stop_;&#125;;// the constructor just launches some amount of workersinline ThreadPool::ThreadPool(size_t threadnum) : stop_(false) &#123; for (size_t i = 0; i &lt; threadnum; ++i) &#123; workers_.emplace_back( [this]&#123; // 为每个线程构造一个调度函数 while (1) &#123; std::function&lt;void()&gt; task; &#123; // 此处花括号使得在执行 task 前即释放互斥锁 std::unique_lock&lt;std::mutex&gt; lock(this-&gt;mutex_); // stop_ 为 false 且 task queue 为空时阻塞线程，其他情况都不阻塞 this-&gt;condition_.wait(lock, [this]&#123; return (this-&gt;stop_ || !this-&gt;tasks_.empty()); &#125;); // 线程结束，用于销毁线程 if (this-&gt;stop_ &amp;&amp; this-&gt;tasks_.empty()) return; if (this-&gt;tasks_.empty() == false) &#123; task = std::move(this-&gt;tasks_.front()); this-&gt;tasks_.pop(); &#125; &#125; task(); &#125; &#125;); &#125;&#125;// the destructor joins all threadsinline ThreadPool::~ThreadPool() &#123; &#123; // 对于所有线程共享的变量操作前都需要加锁 std::unique_lock&lt;std::mutex&gt; lock(mutex_); stop_ = true; &#125; // 唤醒所有阻塞的线程 condition_.notify_all(); for (std::thread &amp;worker : workers_) &#123; // 等待所有线程都执行完 worker.join(); &#125;&#125;// add new task to the task queuebool ThreadPool::EnQueue(std::function&lt;void()&gt; task) &#123; &#123; // 对于 task queue 的操作都需要加锁，因为 task queue 是所有线程共有的 std::unique_lock&lt;std::mutex&gt; lock(mutex_); tasks_.emplace(task); &#125; condition_.notify_one(); return true;&#125;#endif // _THREADPOOL_H_ 测试代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include \"threadpool.h\"using std::cout;using std::endl;class Test &#123; public: void process_to_test(const int i, const int j) &#123; int count = 0; for (int x = 0; x &lt; i; ++x) &#123; for (int y = 0; y &lt; j; ++y) &#123; ++count; &#125; &#125; cout &lt;&lt; \"Thread num: \" &lt;&lt; -(i - 8) &lt;&lt; \" \" &lt;&lt; count &lt;&lt; endl; &#125;&#125;;int main() &#123; Test test; ThreadPool pool(8); for (unsigned i = 0; i &lt; 8; ++i) &#123; pool.EnQueue(std::bind(&amp;Test::process_to_test, &amp;test, 8 - i, 1000000)); &#125; return 0;&#125; 参考 Progschj/ThreadPool：https://github.com/progschj/ThreadPool C++11线程池实现：https://blog.csdn.net/zdarks/article/details/46994607 线程池的原理及实现：https://blog.csdn.net/Hsuxu/article/details/8985931 基于c++11的100行实现简单线程池：https://blog.csdn.net/gcola007/article/details/78750220 C++11并发学习之六：线程池的实现：https://blog.csdn.net/caoshangpa/article/details/80374651 使用C++11实现线程池的两种方法：https://blog.csdn.net/liushengxi_root/article/details/83932654","tags":[{"name":"C++","slug":"C","permalink":"https://songkc.github.io/tags/C/"},{"name":"C++11","slug":"C-11","permalink":"https://songkc.github.io/tags/C-11/"},{"name":"并发编程","slug":"并发编程","permalink":"https://songkc.github.io/tags/并发编程/"}]},{"title":"Reactor 模式","date":"2019-02-25T13:15:09.000Z","path":"2019/02/25/Reactor模式/","text":"什么是 Reactor 模式反应器设计模式（Reactor pattern）是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的事件设计模式。当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求，然后派发这些请求至相关的工作线程进行处理。 Reactor 模式结构 Handle：句柄，指 Windows 中的句柄，在 Linux 中一般称为文件描述符，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个套接字（Socket）、Timer 等。由于 Reactor 模式一般使用在网络编程中，因而这里一般指 Socket Handle，即一个网络连接（Connection）。这个 Handle 注册到 Synchronous Event Demultiplexer 中，以监听 Handle 中发生的事件，对 Server Socket Handle 可以是 CONNECT 事件，对 Socket Handle 可以是 READ、WRITE、CLOSE 事件等。 Synchronous Event Demultiplexer：同步事件分离器，本质上是系统调用。比如 Linux 中的 select、poll、epoll。会阻塞等待一系列的 Handle 中的事件到来，如果阻塞等待返回，即表示在返回的 Handle 中可以不阻塞的执行返回的事件。 Initiation Dispatcher：初始分发器，用于管理 Event Handler，即 Event Handler 的容器，提供注册、移除 Event Handler 的方法；另外，它还作为 Reactor 模式的入口调用 Synchronous Event Demultiplexer 的 select 方法以阻塞等待事件返回，当阻塞等待返回时，根据发生事件的 Handle，Initiation Dispatcher 将其分发给对应的 Event Handler 处理，即回调 Event Handler 中的 handle_event() 方法。 Event Handler：事件处理器，定义事件处理方法：handle_event()，以供 Initiation Dispatcher 回调使用。当 Handle 上有事件发生时，回调方法便会执行，一种事件处理机制。 Concrete Event Handler：具体的事件处理器，事件 Event Handler 的接口，实现特定事件处理的业务逻辑。 Reactor 模式处理流程 （1）初始化 Initiation Dispatcher，并初始化一个 Handle 到 Event Handler 的映射（Map）。 （2）注册 Event Handler 到 Initiation Dispatcher 上，每个 Event Handler 包含对相应 Handle 的引用，从而建立 Handle 到 Event Handler 的映射（Map）。 （3）当所有的 Event Handler 都注册到 Initiation Dispatcher 上后，Initiation Dispatcher 会调用 handle_events() 方法来启动 Initiation Dispatcher 的事件循环，这时 Initiation Dispatcher 会将每个 Event Handler 关联的 Handle 合并，并使用 Synchronous Event Demultiplexer 调用 select() 方法来阻塞等待 Handle 上事件的发生。 （4）当与某个或某些 Handle 对应的 Event 发生时，Synchronous Event Demultiplexer 便会通知 Initiation Dispatcher。 （5）Initiation Dispatcher 会根据相应的 Handle 触发 Event Handler 的 handle_event() 回调方法。 （6）在 Event Handler 的 handle_events() 方法中还可以向 Initiation Dispatcher 中注册新的 Event Handler。比如对 Acceptor Event Handler 来说，当有新的 Client 连接时，它会产生新的 Event Handler 以处理新的连接，并注册到 Initiation Dispatcher 中。 Reactor 模式实例在 Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events 中，一直以 Logging Server 来分析 Reactor 模式，这个 Logging Server 的实现完全遵循这里对 Reactor 的描述，因而放在这里以做参考。 Logging Server 中的 Reactor 模式实现分两个部分：Client 连接到 Logging Server 和 Client 向 Logging Server 写 log 。因而对它的描述分成这两个步骤。 Client 连接到 Logging Server （1）Logging Server 注册 Logging Acceptor 到 Initiation Dispatcher。 （2）Logging Server 调用 Initiation Dispatcher 的 handle_events() 方法启动。 （3）Initiation Dispatcher 内部（Synchronous Event Demultiplexer）调用 select() 方法，阻塞等待 Client 连接。 （4）Client 连接到 Logging Server。 （5）Initiation Disptcher 中的（Synchronous Event Demultiplexer） select() 方法返回，并根据返回找到 Logging Acceptor 并告知其有新的连接到来。 （6）Logging Acceptor 调用 accept() 方法接受这个新连接。 （7）Logging Acceptor 调用 create() 方法创建新的 Logging Handler。 （8）新的 Logging Handler 注册到 Initiation Dispatcher 中(同时也注册到 Synchonous Event Demultiplexer 中)，等待 Client 发起写 log 请求。 Client 向 Logging Server 写 log （1）Client 发送 log 到 Logging Server。 （2）Initiation Dispatcher 中的（Synchronous Event Demultiplexer）监测到相应的 Handle 中有事件发生，select() 方法返回，根据返回的 Handle 找到 Logging Handler，并回调 Logging Handler 中的 handle_event() 方法。 （3）Logging Handler 中的 handle_event() 方法中使用 recv() 方法读取 Handle 中的 log 信息。 （4）将接收到的 log 信息使用 write() 方法写入到日志文件、数据库等中。步骤 3 和 4 循环直到当前日志处理完成。 （5）返回到 Initiation Dispatcher 等待下一次日志写请求。 如何使用 Reactor 模式在网络服务和分布式对象中，对于网络中的某一个请求处理，我们比较关注的内容大致为：读取请求（Read request）、 解码请求（Decode request）、处理服务（Process service）、 编码答复（Encode reply）、 发送答复（Send reply）。但是每一步对系统的开销和效率又不尽相同。 传统服务设计（Classic Service Design）对于传统的服务设计，每一个到来的请求，系统都会分配一个线程去处理，这样看似合乎情理，但是，当系统请求量瞬间暴增时，会直接把系统拖垮。因为在高并发情况下，系统创建的线程数量是有限的。传统系统设计如下图所示： 基础 Reactor 设计（Basic Reactor Design）单线程版的 Reactor 模式如下图所示。对于客户端的所以请求，都又一个专门的线程去进行处理，这个线程无线循环去监听是否又客户的请求到来，一旦收到客户端的请求，就将其分发给响应的处理器进行处理。 工作线程池 Reactor 设计（Worker Thread Pools for Reactor）考虑到工作线程的复用，将工作线程设计为线程池。将处理器的执行放入线程池，多线程进行业务处理。但 Reactor 仍为单个线程。工作线程使用线程池实现如下图所示。 多 Reactor 设计（Multiple Reactor Design）对于多个 CPU 的机器，为充分利用系统资源，将 Reactor 拆分为两部分。MainReactor 负责监听连接，accept 连接给 SubReactor 处理，为什么要单独分一个 Reactor 来处理监听呢？因为像 TCP 这样需要经过3次握手才能建立的连接，建立连接的过程也是要耗时间和资源的，单独分一个 Reactor 来处理，可以提高性能。实现如下图所示。 总结优点（1）响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的。 （2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销。 （3）可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源。 （4）可复用性，Reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性。 缺点（1）相比传统的简单模型，Reactor 增加了一定的复杂性，因而有一定的门槛，并且不易于调试。 （2）Reactor 模式需要底层的 Synchronous Event Demultiplexer 支持，比如 Java 中的 Selector 支持，操作系统的 select 系统调用支持，如果要自己实现 Synchronous Event Demultiplexer 可能不会有那么高效。 （3） Reactor 模式在 I/O 读写数据时还是在同一个线程中实现的，即使使用多 个Reactor 机制的情况下，那些共享一个 Reactor 的 Handle 如果出现一个长时间的数据读写，会影响这个 Reactor 中其他 Handle 的相应时间，比如在大文件传输时，I/O 操作就会影响其他 Client 的相应时间，因而对这种操作，使用传统的 Thread-Per-Connection 或许是一个更好的选择，或则此时使用 Proactor 模式。 参考 Reactor模式：https://www.jianshu.com/p/eef7ebe28673 高性能IO之Reactor：https://www.cnblogs.com/doit8791/p/7461479.html 细说Reactor模式：https://blog.csdn.net/u010168160/article/details/53019039 Reactor模式是什么：https://blog.csdn.net/u013219087/article/details/81229873 Reactor模式详解：http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html Reactor（反应器）模式初探：https://blog.csdn.net/pistolove/article/details/53152708 Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events","tags":[{"name":"I/O","slug":"I-O","permalink":"https://songkc.github.io/tags/I-O/"}]},{"title":"Linux - I/O 模型","date":"2019-02-19T11:33:37.000Z","path":"2019/02/19/Linux-I-O模型/","text":"基础知识用户空间和内核空间以下皆是基于 Linux，现代操作系统都是采用虚拟寻址，处理器先产生一个虚拟地址，通过地址翻译成物理地址（内存的地址），再通过总线的传递，最后处理器拿到物理地址存储的数据。 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。 对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。针对 Linux 操作系统而言，将最高的 1G 地址（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 地址（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。 进程上下文切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程的上下文切换（也叫调度）。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： （1）保存当前进程 A 的上下文。上下文就是内核再次唤醒当前进程时所需要的状态，由一些对象（程序计数器、状态寄存器、用户栈等各种内核数据结构）的值组成。 （2）切换页全局目录以安装一个新的地址空间。 （3）恢复进程 B 的上下文。 进程上下文切换是一个比较消耗资源的过程。 进程的阻塞正在运行状态的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语（Block），使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行状态的进程（已获得 CPU），才可能将其转为阻塞状态。当进程转入阻塞状态时，是不占用 CPU 资源的。 文件描述符在 Linux 系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行 I/ O操作的系统调用都通过文件描述符。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。 直接 I/O 和 缓存 I/O缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，以 write 操作为例，数据会先被拷贝到进程缓冲区，再拷贝到操作系统内核的缓冲区中，然后才会写到相应存储设备中。 缓存 I/O 的 write 操作： 直接 I/O 的 write 操作： write 操作过程中会有很多次拷贝，直到数据全部拷贝到磁盘。 I/O 模式对于一次 I/O 访问（这里以 read 操作举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区，最后交给进程。 所以说，当一个 read 操作发生时，它会经历两个阶段： （1）等待数据准备（Waiting for the data to be ready） （2）将数据从内核拷贝到进程中（Copying the data from the kernel to the process） 正式因为这两个阶段，Linux 系统产生了下面五种网络模式的方案： （1）阻塞 I/O（Blocking I/O） （2）非阻塞 I/O（Non-blocking I/O） （3）I/O 多路复用（I/O multiplexing） （4）信号驱动 I/O（Signal driven I/O） （5）异步 I/O（Asynchronous I/O） 阻塞 I/O（Blocking I/O） 以 read 操作为例： （1）进程发起read，进行recvfrom系统调用； （2）内核开始第一阶段，准备数据（从磁盘拷贝到内核缓冲区），进程请求的数据并不是一下就能准备好；准备数据是要消耗时间的； （3）与此同时，进程阻塞（进程是自己选择阻塞与否），等待数据中； （4）直到数据从内核拷贝到了用户空间，内核返回结果，进程解除阻塞。 也就是说，内核准备数据和数据从内核拷贝到进程内这两个过程都是阻塞的。 非阻塞（Non-blocking I/O） （1）当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好； （2）那么它并不会阻塞用户进程，而是立刻返回一个 error，从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果； （3）用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call； （4）那么它马上就将数据拷贝到了用户内存，然后返回。 所以，Non-blocking I/O 的特点是用户进程在内核准备数据的阶段需要不断的主动询问数据是否准备好。但是，轮寻对于 CPU 来说是较大的浪费，一般只有在特定的场景下才使用。 I/O 多路复用（I/O multiplexing） I/O 多路复用实际上就是用 select, poll, epoll 监听多个 I/O 对象，当 I/O 对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个 Socket。I/O 多路复用的流程： （1）当用户进程调用了 select，那么整个进程会被阻塞； （2）而同时，kernel 会“监视”所有 select 负责的 Socket； （3）当任何一个 Socket 中的数据准备好了，select 就会返回； （4）这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。 所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select() 函数就可以返回。 这个图和 Blocking I/O 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个 system call (select 和 recvfrom)，而 Blocking I/O 只调用了一个 system call (recvfrom)。但是，用 select 的优势在于它可以同时处理多个连接。 所以，如果处理的连接数不是很高的话，使用 select/epoll 的 Webserver 不一定比使用多线程 + Blocking I/O 的 Webserver 性能更好，可能延迟还更大。select/epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 在 I/O multiplexing 模型中，对于每一个 Socket，一般都设置成为 Non-blocking，但如上图所示，整个用户进程其实是一直被阻塞的，只不过进程是被 select 这个函数阻塞，而不是被 Socket I/O 操作给阻塞。 信号驱动 I/O（Signal driven I/O） （1）用户进程建立 sigio 的信号处理程序，系统调用 sigaction 执行信号处理函数（非阻塞，立刻返回） （2）当 kernel 中的数据准备好了，系统生成 sigio 信号，通过信号回调通知用户进程来读取数据； （3）这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程。 异步 I/O（Asynchronous I/O） （1）用户进程发起 read 操作之后，立刻就可以开始去做其它的事； （2）而另一方面，从 kernel 的角度，当它收到一个 asynchronous read 操作之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞； （3）然后 kernel 会等待数据准备完成，数据准备好后直接将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个 signal，告诉用户进程 read 操作完成了。 总结Blocking 和 Non-blocking 的区别使用 Blocking I/O 会一直阻塞住对应的进程直到操作完成，而 Non-blocking I/O 在 kernel 还没准备好数据的情况下会立刻返回。 Synchronous 和 Asynchronous 的区别在说明 Synchronous I/O 和 Asynchronous I/O 的区别之前，需要先给出两者的定义。POSIX 的定义是这样子的： A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes; An asynchronous I/O operation does not cause the requesting process to be blocked; 两者的区别就在于 Synchronous I/O 进行 I/O 操作的时候会将进程阻塞。按照这个定义，之前所述的 Blocking I/O，Non-blocking I/O，I/O multiplexing 都属于 Synchronous I/O。 有人会说 Non-blocking I/O 并没有被阻塞，然而这里有个非常“狡猾”的地方，定义中所指的 ”IO operation” 是指真实的 I/O 操作，就是例子中的 recvfrom 这个 system call。Bon-blocking I/O 在执行 recvfrom 这个system call的时候，如果 kernel 的数据没有准备好，这时候不会阻塞进程。但是，当 kernel 中数据准备好的时候，recvfrom 会将数据从 kernel 拷贝到用户内存中，这个时候进程是被阻塞的。 而 Asynchronous I/O 则不一样，当进程发起 I/O 操作之后，就直接返回继续执行其他任务，直到 kernel 发送一个信号，告诉进程说 I/O 完成。在这整个过程中，进程完全没有被阻塞的。 Non-blocking I/O 和 Asynchronous I/O的区别可以发现 Non-blocking I/O 和 Asynchronous I/O 的区别还是很明显的。 在 Non-blocking I/O 中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程主动的去检查数据是否准备好，并且当数据准备完成以后，也需要进程主动的再次调用 recvfrom 来将数据拷贝到用户内存。 而 Asynchronous I/O 则完全不同。它就像是用户进程将整个 I/O 操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查 I/O 操作的状态，也不需要主动的去拷贝数据。 参考 通俗易懂讲解IO模型：https://www.cnblogs.com/javalyy/p/8882066.html 五种IO模型：https://blog.csdn.net/ZWE7616175/article/details/80591587 IO模式和IO多路复用：https://www.cnblogs.com/zingp/p/6863170.html","tags":[{"name":"Linux","slug":"Linux","permalink":"https://songkc.github.io/tags/Linux/"},{"name":"I/O","slug":"I-O","permalink":"https://songkc.github.io/tags/I-O/"}]},{"title":"C++11 - Lambda 表达式","date":"2018-12-29T09:01:42.000Z","path":"2018/12/29/C++11-Lambda表达式/","text":"C++11 的一大亮点就是引入了 Lambda 表达式。利用 Lambda 表达式，可以方便的定义和创建匿名函数。 声明 Lambda 表达式Lambda 表达式完整的声明格式如下： 1[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; 各项具体含义如下： capture list：捕获外部变量列表 params list：形参列表 mutable：用来说用是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 此外，我们还可以省略其中的某些成分来声明“不完整”的 Lambda 表达式，常见的有以下几种： 序号 格式 1 [capture list] (params list) -&gt; return type { function body } 2 [capture list] (params list) { function body } 3 [capture list] { function body } 格式 1 声明了 const 类型的表达式，这种类型的表达式不能修改捕获列表中的值。 格式 2 省略了返回值类型，但编译器可以根据以下规则推断出 Lambda 表达式的返回类型： 如果 function body 中没有 return 语句，则返回值为 void 类型； 如果 function body 中存在 return 语句，则该 Lambda 表达式的返回类型由 return 语句的返回类型确定。 格式 3 中省略了参数列表，类似普通函数中的无参函数。 捕获外部变量Lambda 表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该 Lambda 表达式使用）。那么，在哪里指定这些外部变量呢？Lambda 表达式通过在最前面的方括号 [] 来明确指明其内部可以访问的外部变量，这一过程也称作 Lambda 表达式“捕获”了外部变量。 通过一个例子来直观地说明一下： 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; f(); // 输出：123 //或通过“函数体”后面的‘()’传入参数 auto x = [](int a)&#123; cout &lt;&lt; a &lt;&lt; endl; &#125;(123); return 0;&#125; 上面这个例子先声明了一个整型变量 a，然后再创建 Lambda 表达式，该表达式“捕获”了变量 a，这样在 Lambda 表达式函数体中就可以获得该变量的值。 类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。 值捕获值捕获和参数传递中的值传递类似，被捕获的变量的值在 Lambda 表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响 Lambda 表达式中的值。示例如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; a = 321; f(); // 输出：123 return 0;&#125; 这里需要注意的是，如果以传值方式捕获外部变量，则在 Lambda 表达式函数体中不能修改该外部变量的值。 引用捕获使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符 &amp;。如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; a = 321; f(); // 输出：321 return 0;&#125; 从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。 隐式捕获上面的值捕获和引用捕获都需要我们在捕获列表中显式列出 Lambda 表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是 [=] 和 [&amp;]。[=] 表示以值捕获的方式捕获外部变量，[&amp;] 表示以引用捕获的方式捕获外部变量。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; // 隐式值捕获 a = 321; f(); // 输出：123 int b = 123; auto func = [&amp;] &#123; cout &lt;&lt; b &lt;&lt; endl; &#125;; // 隐式引用捕获 b = 321; func(); // 输出：321 return 0;&#125; 混合方式上面的例子，要么是值捕获，要么是引用捕获，Lambda 表达式还支持混合的方式捕获外部变量，混合方式主要是以上几种捕获方式的组合使用。 总结一下，C++11 中的 Lambda 表达式捕获外部变量主要有以下形式： 捕获形式 说明 [] 不捕获任何外部变量 [变量名, …] 默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符） [this] 以值的形式捕获this指针 [=] 以值的形式捕获所有外部变量 [&amp;] 以引用形式捕获所有外部变量 [=, &amp;x] 变量x以引用形式捕获，其余变量以传值形式捕获 [&amp;, x] 变量x以值的形式捕获，其余变量以引用形式捕获 修改捕获变量前面我们提到过，在 Lambda 表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用 mutable 关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 123; auto f = [a]()mutable &#123; cout &lt;&lt; ++a; &#125;; // OK cout &lt;&lt; a &lt;&lt; endl; // 输出：123 f(); // 输出：124 return 0;&#125; Lambda 表达式的参数Lambda 表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在 Lambda 表达式中传递参数还有一些限制，主要有以下几点： 参数列表中不能有默认参数 不支持可变参数 所有参数必须有参数名","tags":[{"name":"C++","slug":"C","permalink":"https://songkc.github.io/tags/C/"},{"name":"C++11","slug":"C-11","permalink":"https://songkc.github.io/tags/C-11/"}]},{"title":"LeetCode - 671. Second Minimum Node in a Binary Tree","date":"2018-10-15T02:01:22.000Z","path":"2018/10/15/LeetCode-671-Second-Minimum-Node-In-a-Binary-Tree/","text":"DescriptionGiven a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example12345678910111213141516171819// Example 1Input: 2 / \\ 2 5 / \\ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5.// Example 2Input: 2 / \\ 2 2Output: -1Explanation: The smallest value is 2, but there isn't any second smallest value. Interface123456789101112131415/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int findSecondMinimumValue(TreeNode* root) &#123; &#125;&#125;; Solution由题意可知，父节点的值一定小于等于两个子节点的值，因而根节点的值一定是最小值，那么可以推导出值第二小的节点在根节点的左子树中或在根节点的右子树中或不存在，同时，当一个节点的值大于根节点的值(即最小值)时，由于父节点的值一定小于等于两个子节点的值，那么由该节点衍生的子树的节点的值一定大于等于该节点的值，因此该节点衍生的子树并不需要检查。 解决的方法有多种，这里我使用了 BFS（广度优先搜索）。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // unrecursion by BFS int findSecondMinimumValue(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; que.push(root); int min = root-&gt;val; int left, right, smin = INT_MAX; while (!que.empty()) &#123; TreeNode* temp = que.front(); if (min &lt; temp-&gt;val) &#123; smin = (smin &gt; temp-&gt;val ? temp-&gt;val : smin); que.pop(); continue; &#125; if (temp-&gt;left != NULL &amp;&amp; temp-&gt;right != NULL) &#123; que.push(temp-&gt;left); que.push(temp-&gt;right); &#125; que.pop(); &#125; return smin == INT_MAX ? -1 : smin; &#125;&#125;; Improvement学习了一下 LeetCode 上讨论区的做法，将递归和分治的做法也写出来。 Recursion Method（递归方法）1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // recursion int findSecondMinimumValue(TreeNode* root) &#123; if (!root) return -1; return findSecMin(root, root-&gt;val); &#125; int findSecMin(TreeNode* node, int first) &#123; if (!node) return -1; if (node-&gt;val &gt; first) return node-&gt;val; int left = findSecMin(node-&gt;left, first); int right = findSecMin(node-&gt;right, first); if (left == -1 &amp;&amp; right == -1) return -1; if (left != -1 &amp;&amp; right == -1) return left; if (right != -1 &amp;&amp; left == -1) return right; &#125;&#125;; Divide and Conquer Method （分治方法）123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // divide and conquer int findSecondMinimumValue(TreeNode* root) &#123; if (!root) return -1; if (!root-&gt;left &amp;&amp; !root-&gt;right) return -1; int left = root-&gt;left-&gt;val; int right = root-&gt;right-&gt;val; if (left == root-&gt;val) left = findSecondMinimumValue(root-&gt;left); if (right == root-&gt;val) right = findSecondMinimumValue(root-&gt;right); if (left == -1 &amp;&amp; right == -1) return -1; else if (left == -1) return right; else if (right == -1) return left; else return left &gt; right ? right : left; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://songkc.github.io/tags/二叉树/"}]},{"title":"LeetCode - 32. Longest Valid Parentheses","date":"2018-10-11T06:41:29.000Z","path":"2018/10/11/LeetCode-32-Longest-Valid-Parentheses/","text":"Description Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. Example12345For \"(()\", the longest valid parentheses substring is \"()\", which haslength = 2.Another example is \")()())\", where the longest valid parenthesessubstring is \"()()\", which has length = 4. Interface123456class Solution &#123;public: int longestValidParentheses(string s) &#123; &#125;&#125;; Solution一开始只是简单的以为是求出所有合法的圆括号的数量，就直接用一个栈去写，提交后才发现理解错了，原来题目的意思是从找出字符串中最长的合法圆括号子串的长度。 重新审题后就能发现每个合法的字串其实都是由不合法的字串分隔开的，我的思路是用一个栈存储 pair&lt;char, int&gt; 类型的元素，char 为圆括号字符，int 为此时所有合法的圆括号数量。当栈顶元素字符为 ‘(‘ 且当前字符为 ‘)’ 时，就将栈顶元素 pop 出，并将合法圆括号数量 +2，到最后栈中留下的都是不合法的圆括号，其实就相当于将合法的圆括号字串分隔开的分隔符，此时就可以利用这些分隔符求出每个合法圆括号字串的长度，取最大的字串长度即可。算法的复杂度是 $O(n^2)$。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int longestValidParentheses(string s) &#123; if (s.length() == 0) return 0; int count = 0, max = 0; stack&lt;pair&lt;char, int&gt; &gt; stk; pair&lt;char, int&gt; p(s[0], 0); stk.push(p); for (int i = 1; i &lt; s.length(); ++i) &#123; if (stk.empty()) &#123; pair&lt;char, int&gt; temp(s[i], count); stk.push(temp); continue; &#125; pair&lt;char, int&gt; top = stk.top(); if (top.first == '(' &amp;&amp; s[i] == ')') &#123; count += 2; stk.pop(); &#125; else &#123; pair&lt;char, int&gt; temp(s[i], count); stk.push(temp); continue; &#125; &#125; while (!stk.empty()) &#123; pair&lt;char, int&gt; top = stk.top(); if (top.second == count) &#123; stk.pop(); continue; &#125; int temp = count - top.second; if (max &lt; temp) max = temp; count -= temp; stk.pop(); &#125; if (max &lt; count) max = count; return max; &#125;&#125;; Improvement精简代码LeetCode 讨论区发现，许多解答思路与我的思路是一样的，但我的代码显得有些冗余了，附上精简后的代码。 12345678910111213141516class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; stk.push(-1); int maxL = 0, temp = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; temp = stk.top(); if (temp != -1 &amp;&amp; s[i] == ')' &amp;&amp; s[temp] == '(') &#123; stk.pop(); maxL = max(maxL, i - stk.top()); &#125; else stk.push(i); &#125; return maxL; &#125;&#125;; 动态规划还有用使用动态规划（DP）算法来解题的思路，这里也在此附上。 12345678910111213141516171819202122class Solution &#123;public: int longestValidParentheses(string s) &#123; int *V = new int[s.length()]; int open = 0, max = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (s[i] == '(') ++open; if (s[i] == ')' &amp;&amp; open &gt; 0) &#123; // matches found V[i] = V[i - 1] + 2; // add matches from previous if (i - V[i] &gt; 0) V[i] += V[i - V[i]]; --open; &#125; if (V[i] &gt; max) max = V[i]; &#125; delete V; return max; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://songkc.github.io/tags/字符串/"},{"name":"动态规划","slug":"动态规划","permalink":"https://songkc.github.io/tags/动态规划/"}]},{"title":"LeetCode - 551. Student Attendance Record I","date":"2018-10-05T01:02:33.000Z","path":"2018/10/05/LeetCode-551-Student-Attendence-Record-I/","text":"DescriptionYou are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present. A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record. ExampleExample 112Input: \"PPALLP\"Output: True Example 212Input: \"PPALLL\"Output: False Interface123456class Solution &#123;public: bool checkRecord(string s) &#123; &#125;&#125;; Solution先分析题目，根据题目的意思是说，只要缺勤超过两次或者迟到超过两次且是连续的就应该返回 false，缺勤超过两次这个直接记录就 OK，而这题的重点用更通俗的话来讲就是连续两天以上迟到，其实最简单的做法就是用一个变量 late 记录迟到的次数，迟到则加 1，不是迟到的则将 late 重置为 0，然后判断 late 是否大于 2 即可。这题算是比较简单的，巧妙的 if-else 就可以做出。 12345678910111213class Solution &#123;public: bool checkRecord(string s) &#123; int abs = 0, late = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (s[i] == 'A') abs++; if (s[i] == 'L') late++; else late = 0; if (abs &gt; 1 || late &gt; 2) return false; &#125; return true; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"https://songkc.github.io/tags/字符串/"}]},{"title":"LeetCode - 48. Rotate Image","date":"2018-09-30T11:54:52.000Z","path":"2018/09/30/LeetCode-48-Rotate-Image/","text":"Description You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. ExampleExample 112345678910111213Given input matrix =[ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Example 2123456789101112131415Given input matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]],rotate the input matrix in-place such that it becomes:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] Interface123456class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; &#125;&#125;; Solution问题主要在于不能使用额外的2维矩阵去求解，思路其实就是由内圈到外圈将整个矩阵顺时针旋转 90°，一是存放当前位置的值以便旋转后将值赋值到旋转后的新位置，二是推导出从当前位置到旋转后的新位置的公式，上述一二操作循环四个数字即可。整个算法的时间复杂度是 $O(n^2)​$。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int temp = 0, row = 0, col = 0, tmp = 0; for (int i = 0; i &lt; matrix.size() / 2; ++i) &#123; for (int j = i; j &lt; matrix.size() - i - 1; ++j) &#123; row = i; col = j; for (int k = 0; k &lt; 5; ++k) &#123; tmp = matrix[row][col]; matrix[row][col] = temp; temp = row; row = col; col = matrix.size() - 1 - temp; temp = tmp; &#125; &#125; &#125; &#125;&#125;;/* n represents the matrix's dimension row represents the row of the present position col represents the column of the present position Actually, the transform function can be written as: new_row = col new_col = n - row - 1 Example: 1 2 3 7 2 1 7 4 1 4 5 6 -&gt; 4 5 6 -&gt; 8 5 2 7 8 9 9 8 3 9 6 3*/ ImprovementLeetCode 讨论区上见到的，先将矩阵按主对角线翻转，再将翻转后的矩阵的每一行进行逆序，就可以完成对矩阵的 90° 旋转。 1234567891011121314151617181920class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = m.size(); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; i; ++j) swap(m[i][j], m[j][i]); for(int i = 0; i &lt; n; ++i) reverse(m[i].begin(), m[i].end()); &#125;&#125;;/* Example: 1 2 3 1 4 7 7 4 1 4 5 6 -&gt; 2 5 8 -&gt; 8 5 2 7 8 9 3 6 9 9 6 3*/","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://songkc.github.io/tags/数组/"}]},{"title":"LeetCode - 21. Merge Two Sorted Lists","date":"2018-09-25T05:14:51.000Z","path":"2018/09/25/LeetCode-21-Merge-Two-Sorted-Lists/","text":"Description Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; Solution合并两个已按小到大排序的链表，最简单的做法就是新建一个链表，然后比较原有的两个链表当前节点的大小，然后选择较小的节点加到新建链表上，接着将被选中的链表的节点指向他的下一个，重复以上，知道某个链表已读到末尾或两个链表都为空，然后将未读完的链表的节点直接加到新建链表上就可以。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* head = new ListNode(0); ListNode* node = head; while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; node-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; node-&gt;next = l2; l2 = l2-&gt;next; &#125; node = node-&gt;next; &#125; node-&gt;next = (l1 == NULL ? l2 : l1); node = head; head = head-&gt;next; delete node; return head; &#125;&#125;; Improvement还可以通过递归实现，原理与上面相同。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; ListNode* node; if (l1-&gt;val &lt; l2-&gt;val) &#123; node = l1; node-&gt;next = mergeTwoLists(l1-&gt;next, l2); &#125; else &#123; node = l1; node-&gt;next = mergeTwoLists(l1, l2-&gt;next); &#125; return node; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"LeetCode - 2. Add Two Numbers","date":"2018-09-19T02:58:21.000Z","path":"2018/09/19/LeetCode-2-Add-Two-Numbers/","text":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example12345Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; Solution题目挺简单的，就是通过链表实现大数加法，结果的每一位由三个值决定，两个是两个加数在这个数位上的值，剩下一个是上一位的进位，主要就是需要注意进位的实现，也没什么难度，可能还有需要注意的就是代码的逻辑需要简明清晰，不然很容易写的很冗长。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; int n1 = 0, n2 = 0, tmp = 0, carry = 0; ListNode *p1 = l1, *p2 = l2, *temp = NULL, *result = NULL; while (p1 != NULL || p2 != NULL || carry != 0) &#123; n1 = (p1 != NULL) ? p1-&gt;val : 0; n2 = (p2 != NULL) ? p2-&gt;val : 0; tmp = n1 + n2 + carry; carry = tmp / 10; if (result == NULL) result = new ListNode(tmp % 10); else temp-&gt;next = new ListNode(tmp % 10); p1 = (p1 == NULL) ? p1 : p1-&gt;next; p2 = (p2 == NULL) ? p2 : p2-&gt;next; if (temp == NULL) temp = result; else temp = temp-&gt;next; &#125; return result; &#125;&#125;; Improvement在 LeetCode 讨论区中发现了更简洁的代码。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"LeetCode - 1. Two Sum","date":"2018-09-12T14:20:34.000Z","path":"2018/09/12/LeetCode-1-Two-Sum/","text":"DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Interface123456class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; &#125;&#125;; Solution一开始，我想到用 stl::map 来解决，数组元素值作为 map 的键，下标则是作为对应的值。将 target 减去当前元素值，看 map 中是否存在差值的键值，如果存在就说明找到了，不存在则将当前元素值和对应下标存入 map 中，以便后面的元素能对应。 但是，我发现如果出现目标是一个元素的两倍，那么输出的结果将是两次那个元素的下标。为了解决这个情况，我调整了一下语句的顺序，将对 map 赋值的语句放到查找后，这样就不会出现上面所说的问题了。 1234567891011121314151617181920// e.gintput: [2 4 4 7 10], target = 8output: [1 1]class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; reflect; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; if (reflect.find(target - nums[i]) != reflect.end()) &#123; result.push_back(reflect[target - nums[i]]); result.push_back(reflect[nums[i]]); return result; &#125; reflect[nums[i]] = i; &#125; return result; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://songkc.github.io/tags/数组/"},{"name":"哈希表","slug":"哈希表","permalink":"https://songkc.github.io/tags/哈希表/"}]},{"title":"Hello World","date":"2018-09-01T04:00:00.000Z","path":"2018/09/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://songkc.github.io/tags/Hexo/"}]}]