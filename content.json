[{"title":"LeetCode - 142. Linked List Cycle II","date":"2019-03-23T13:28:14.000Z","path":"2019/03/23/LeetCode-142-Linked-List-Cycle-II/","text":"DescriptionGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. ExampleExample 11234Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to thesecond node. Example 21234Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to thefirst node. Example 3123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; &#125;&#125;; Solution使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = head; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (head != nullptr) &#123; if (nodeset.count(head) &gt; 0) return head; nodeset.insert(head); head = head-&gt;next; &#125; return nullptr; &#125;&#125;; Improvement使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == nullptr) return nullptr; ListNode *slow = head, *fast = head; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = head; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"剑指Offer - 链表中环的入口结点","date":"2019-03-23T10:11:33.000Z","path":"2019/03/23/剑指Offer-链表中环的入口结点/","text":"题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则返回 NULL。 接口12345678910111213141516/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; &#125;&#125;; 解答使用 stl::mapmap&lt;ListNode*, int&gt; 将 ListNode* 与 ListNode* 出现的次数进行对应，如果单链表中不存在环则，则遍历到尾结点的 next 指向的 nullptr 时就会结束遍历，返回 nullptr；而如果单链表中存在环，第一个出现次数大于 1 的结点即环的入口结点。 12345678910111213141516171819202122232425/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::map ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; map&lt;ListNode*, int&gt; lmap; ListNode *node = pHead; while (node != nullptr) &#123; if (lmap.count(node) &gt; 0) break; else (lmap[node] = 1); node = node-&gt;next; &#125; return node; &#125;&#125;; 使用 stl::set与使用 stl::map 的思路相似，故不再叙述。 123456789101112131415161718192021222324/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via stl::set ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; set&lt;ListNode*&gt; nodeset; while (pHead != nullptr) &#123; if (nodeset.count(pHead) &gt; 0) return pHead; nodeset.insert(pHead); pHead = pHead-&gt;next; &#125; return nullptr; &#125;&#125;; 使用快慢指针设定两个指针，一个慢指针，一个快指针，慢指针一次走的距离是一个结点，而快指针一次走的距离是两个结点，即快指针的速度是慢指针的两倍。 此时，会出现两种情况： 单链表中不存在环则：快指针往后遍历的过程中，会遍历到 nullptr 结点，即单链表中不存在环，最后一个结点指向的是 nullptr。 单链表中存在环则：由于存在环，则快慢指针最后都会进入环中并在环中一直循环，由于快慢指针存在速度差，只要快慢指针一直在环中循环，最终会在环中的一个结点相遇，相遇时快指针至少在环中循环了一圈。 如果这时快指针已经是在环里走了 1 圈（对应于非环部分较短的情况）： 此时快指针走了 2(x + d) (0 &lt;= d) 距离，2(x + d) = x + y + d ，可得 x = y - d ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针会在环入口结点处相遇。 如果这时快指针已经是在环里走了不止一圈，假设为 k 圈： 此时快指针走了 2(x + d) (0 &lt;= d)​ 距离，2(x + d) = x +ky + d​，可得 x = ky - d​ ，此时再同时从第一次相遇点和头结点出发，速度都为一个结点每次，最后两指针也会在环入口结点处相遇。 1234567891011121314151617181920212223242526272829303132/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // method via fast pointer and slow pointer ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (pHead == nullptr) return nullptr; ListNode *slow = pHead, *fast = pHead; do &#123; if (fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; else &#123; return nullptr; &#125; &#125; while (slow != fast); fast = pHead; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125;&#125;; 详细思路参考：一个链表中包含环，请找出该链表的环的入口结点","tags":[{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"}]},{"title":"剑指Offer - 二叉树的镜像","date":"2019-03-22T03:19:58.000Z","path":"2019/03/22/剑指Offer-二叉树的镜像/","text":"题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述1234567二叉树的镜像定义： 源二叉树 镜像二叉树 8 8 / \\ / \\ 6 10 10 6 / \\ / \\ / \\ / \\ 5 7 9 11 11 9 7 5 接口123456789101112131415/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; &#125;&#125;; 解答递归方法对于每个二叉树结点都将左右子结点交换就可以，因此递归是最简短的形式，可以先继续递归左右子结点再交换左右子结点，也可以先交换左右子结点再继续递归左右子结点。 继续递归左右子结点时，可以先检查左右子结点是否为 nullptr，如果子结点是 nullptr，则不需要进行递归，可以减少内存空间和运行时间的消耗，因为递归需要为递归函数的参数和局部变量分配内存空间，同时还需要对递归函数进行压栈操作和递归函数执行及执行完后的出栈操作，这些都需要消耗时间。 1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; if (pRoot-&gt;left != nullptr) Mirror(pRoot-&gt;left); if (pRoot-&gt;right != nullptr) Mirror(pRoot-&gt;right); TreeNode* temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; &#125;&#125;; stl::queue 非递归方法通过队列以层次遍历的方式，遍历每一个二叉树结点，取出结点将左右子结点交换，再将非 nullptr 的子结点加入队列中，直到队列为空。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; queue&lt;TreeNode*&gt; que; que.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (que.empty() == false) &#123; node = que.front(); que.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) que.push(node-&gt;left); if (node-&gt;right != nullptr) que.push(node-&gt;right); &#125; &#125;&#125;; stl::stack 非递归方法与 stl::queue 的思路相似，故不再叙述。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if (pRoot == nullptr) return; stack&lt;TreeNode*&gt; stk; stk.push(pRoot); TreeNode *node = nullptr, *temp = nullptr; while (stk.empty() == false) &#123; node = stk.top(); stk.pop(); temp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = temp; if (node-&gt;left != nullptr) stk.push(node-&gt;left); if (node-&gt;right != nullptr) stk.push(node-&gt;right); &#125; &#125;&#125;;","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://songkc.github.io/tags/剑指Offer/"},{"name":"二叉树","slug":"二叉树","permalink":"https://songkc.github.io/tags/二叉树/"}]},{"title":"LeetCode - 2. Add Two Numbers","date":"2018-09-19T02:58:21.000Z","path":"2018/09/19/LeetCode-2-Add-Two-Numbers/","text":"Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example12345Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. Interface1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; &#125;&#125;; Solution题目挺简单的，就是通过链表实现大数加法，结果的每一位由三个值决定，两个是两个加数在这个数位上的值，剩下一个是上一位的进位，主要就是需要注意进位的实现，也没什么难度，可能还有需要注意的就是代码的逻辑需要简明清晰，不然很容易写的很冗长。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; int n1 = 0, n2 = 0, tmp = 0, carry = 0; ListNode *p1 = l1, *p2 = l2, *temp = NULL, *result = NULL; while (p1 != NULL || p2 != NULL || carry != 0) &#123; n1 = (p1 != NULL) ? p1-&gt;val : 0; n2 = (p2 != NULL) ? p2-&gt;val : 0; tmp = n1 + n2 + carry; carry = tmp / 10; if (result == NULL) result = new ListNode(tmp % 10); else temp-&gt;next = new ListNode(tmp % 10); p1 = (p1 == NULL) ? p1 : p1-&gt;next; p2 = (p2 == NULL) ? p2 : p2-&gt;next; if (temp == NULL) temp = result; else temp = temp-&gt;next; &#125; return result; &#125;&#125;; Improvement在 LeetCode 讨论区中发现了更简洁的代码。 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ListNode* addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://songkc.github.io/tags/链表/"}]},{"title":"LeetCode - 1. Two Sum","date":"2018-09-12T14:20:34.000Z","path":"2018/09/12/LeetCode-1-Two-Sum/","text":"DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Interface123456class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; &#125;&#125;; Solution一开始，我想到用 stl::map 来解决，数组元素值作为 map 的键，下标则是作为对应的值。将 target 减去当前元素值，看 map 中是否存在差值的键值，如果存在就说明找到了，不存在则将当前元素值和对应下标存入 map 中，以便后面的元素能对应。 但是，我发现如果出现目标是一个元素的两倍，那么输出的结果将是两次那个元素的下标。为了解决这个情况，我调整了一下语句的顺序，将对 map 赋值的语句放到查找后，这样就不会出现上面所说的问题了。 1234567891011121314151617181920// e.gintput: [2 4 4 7 10], target = 8output: [1 1]class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; reflect; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; if (reflect.find(target - nums[i]) != reflect.end()) &#123; result.push_back(reflect[target - nums[i]]); result.push_back(reflect[nums[i]]); return result; &#125; reflect[nums[i]] = i; &#125; return result; &#125;&#125;;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://songkc.github.io/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://songkc.github.io/tags/数组/"},{"name":"哈希表","slug":"哈希表","permalink":"https://songkc.github.io/tags/哈希表/"}]},{"title":"Hello World","date":"2018-09-01T04:00:00.000Z","path":"2018/09/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://songkc.github.io/tags/Hexo/"}]}]